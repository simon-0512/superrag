{% extends "base.html" %}

{% block title %}智能问答 - Agorix{% endblock %}

{% block extra_css %}
<!-- Markdown解析库 -->
<script>
console.log(`🔍 [DEBUG] 开始加载外部资源 - ${new Date().toLocaleTimeString()}`);
const resourceLoadStart = performance.now();
</script>
<script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js" onload="console.log(`✅ [DEBUG] marked.js加载完成: ${(performance.now() - resourceLoadStart).toFixed(3)}ms`)" onerror="console.error('❌ [DEBUG] marked.js加载失败')"></script>
<!-- 代码高亮库 -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" onload="console.log(`✅ [DEBUG] highlight.js CSS加载完成`)" onerror="console.error('❌ [DEBUG] highlight.js CSS加载失败，尝试备用CDN')">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" onload="console.log(`✅ [DEBUG] highlight.js加载完成`)" onerror="console.error('❌ [DEBUG] highlight.js加载失败，尝试备用CDN')"></script>
<!-- MathJax数学公式渲染库 -->
<script>
window.MathJax = {
    tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        packages: {'[+]': ['ams', 'newcommand', 'autoload', 'configmacros', 'action']},
        maxMacros: 1000,
        maxBuffer: 5 * 1024
    },
    options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
    },
    startup: {
        ready: function () {
            console.log('MathJax已准备就绪');
            MathJax.startup.defaultReady();
        }
    }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<style>
/* 聊天页面隐藏页脚，为对话区域释放更多空间 */
footer {
    display: none !important;
}

/* 调整主内容区域高度 */
.main-content {
    min-height: calc(100vh - 60px) !important; /* 减去导航栏高度 */
    padding-bottom: 0 !important;
}

/* 聊天页面内容容器 */
.chat-page-content {
    padding: 0 !important;
    margin: 0 !important;
    height: calc(100vh - 60px); /* 减去导航栏高度 */
    overflow: hidden;
}

/* 优化聊天容器高度 */
.chat-container {
    height: 100% !important;
    max-height: none !important;
    border-radius: 0 !important; /* 移除圆角，充分利用空间 */
    box-shadow: none !important;
}

/* 调试面板样式 */
.debug-panel {
    position: fixed;
    top: 60px;
    right: 0;
    width: 500px;
    height: calc(100vh - 60px);
    background: rgba(255, 255, 255, 0.98);
    backdrop-filter: blur(10px);
    border-left: 1px solid #e5e5e5;
    box-shadow: -2px 0 20px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    animation: slideInRight 0.3s ease-out;
}

@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.debug-header {
    padding: 16px;
    border-bottom: 1px solid #e5e5e5;
    display: flex;
    justify-content: between;
    align-items: center;
    background: #f8f9fa;
}

.debug-controls {
    display: flex;
    gap: 8px;
}

.debug-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.debug-tabs {
    display: flex;
    border-bottom: 1px solid #e5e5e5;
    background: #f8f9fa;
}

.debug-tab {
    flex: 1;
    padding: 12px 8px;
    border: none;
    background: none;
    font-size: 12px;
    color: #666;
    cursor: pointer;
    transition: all 0.2s;
}

.debug-tab:hover {
    background: #e9ecef;
    color: #333;
}

.debug-tab.active {
    background: #fff;
    color: #0066cc;
    border-bottom: 2px solid #0066cc;
}

.debug-tab-content {
    flex: 1;
    overflow: hidden;
}

.debug-tab-pane {
    height: 100%;
    overflow: auto;
    padding: 16px;
    display: none;
}

.debug-tab-pane.active {
    display: block;
}

.debug-log {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 12px;
    line-height: 1.4;
}

.debug-info {
    font-size: 12px;
    line-height: 1.5;
}

.debug-entry {
    margin-bottom: 12px;
    padding: 8px;
    background: #f8f9fa;
    border-radius: 4px;
    border-left: 3px solid #dee2e6;
}

.debug-entry.info {
    border-left-color: #0066cc;
}

.debug-entry.success {
    border-left-color: #28a745;
}

.debug-entry.warning {
    border-left-color: #ffc107;
}

.debug-entry.error {
    border-left-color: #dc3545;
}

.debug-entry-header {
    font-weight: bold;
    margin-bottom: 4px;
    display: flex;
    justify-content: between;
    align-items: center;
}

.debug-entry-content {
    color: #666;
}

.debug-json {
    background: #f1f3f4;
    padding: 8px;
    border-radius: 4px;
    overflow-x: auto;
    margin-top: 8px;
    white-space: pre-wrap;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 11px;
}

/* 数据库操作样式 */
.db-operations-section {
    margin-top: 15px;
}

.db-operations-list {
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    background: rgba(255, 255, 255, 0.9);
    padding: 8px;
}

.db-operation {
    padding: 6px 8px;
    margin: 2px 0;
    border-radius: 3px;
    font-size: 12px;
    line-height: 1.4;
}

.db-operation.success {
    background: rgba(40, 167, 69, 0.1);
    border-left: 3px solid #28a745;
}

.db-operation.warning {
    background: rgba(255, 193, 7, 0.1);
    border-left: 3px solid #ffc107;
}

.db-operation.error {
    background: rgba(220, 53, 69, 0.1);
    border-left: 3px solid #dc3545;
}

.db-operation.info {
    background: rgba(0, 123, 255, 0.1);
    border-left: 3px solid #007bff;
}

/* 调试模式下调整聊天区域 */
.chat-main.debug-mode {
    margin-right: 500px;
}



/* 🔥 新增：等待动画样式 */
.waiting-animation {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: #64748b;
    font-size: 0.9rem;
    padding: 0.5rem 0;
}

.waiting-text {
    color: #64748b;
}

.waiting-dots {
    display: flex;
    gap: 0.1rem;
}

.waiting-dots span {
    opacity: 0.4;
    animation: waitingDots 1.5s infinite ease-in-out;
}

.waiting-dots span:nth-child(1) {
    animation-delay: 0s;
}

.waiting-dots span:nth-child(2) {
    animation-delay: 0.2s;
}

.waiting-dots span:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes waitingDots {
    0%, 80%, 100% {
        opacity: 0.4;
        transform: scale(1);
    }
    40% {
        opacity: 1;
        transform: scale(1.2);
    }
}

/* 响应式调整 */
@media (max-width: 1200px) {
    .debug-panel {
        width: 400px;
    }
    .chat-main.debug-mode {
        margin-right: 400px;
    }
}

@media (max-width: 992px) {
    .debug-panel {
        width: 100%;
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
    }
    .chat-main.debug-mode {
        margin-right: 0;
    }
}

/* V0.3.0 紧凑型配置模态框样式 */
#configModal .modal-content {
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
}

#configModal .modal-header {
    border-bottom: 1px solid #e9ecef;
    background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
    border-radius: 12px 12px 0 0;
}

#configModal .modal-body {
    background: #fafbfc;
}

#configModal .form-label.small {
    font-weight: 600;
    color: #495057;
}

#configModal .form-select-sm,
#configModal .form-control-sm {
    font-size: 13px;
    border-radius: 6px;
    border: 1px solid #dee2e6;
    transition: all 0.2s ease;
}

#configModal .form-select-sm:focus,
#configModal .form-control-sm:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

#configModal .form-check-input {
    margin-top: 0.2em;
}

#configModal .form-check-label.small {
    font-size: 12px;
    color: #6c757d;
}

#configModal #configPreview {
    background: linear-gradient(135deg, #e3f2fd 0%, #f1f8e9 100%);
    border: 1px solid #bbdefb;
    border-radius: 8px;
    font-size: 12px;
}

#configModal .collapse {
    transition: all 0.3s ease;
}

#configModal .btn-link {
    color: #6c757d;
    font-size: 12px;
}

#configModal .btn-link:hover {
    color: #007bff;
}

#configModal .modal-footer {
    border-top: 1px solid #e9ecef;
    background: #f8f9fa;
    border-radius: 0 0 12px 12px;
}

/* 输出长度单选按钮样式 */
#maxTokensRadioGroup .form-check {
    margin-right: 1rem;
}

#maxTokensRadioGroup .form-check-input:checked {
    background-color: #007bff;
    border-color: #007bff;
}

#maxTokensRadioGroup .form-check-label {
    font-weight: 500;
    color: #495057;
}

/* 思考过程显示样式 */
.thinking-process {
    background: #f8f9fa;
    border-left: 3px solid #6c757d;
    padding: 12px;
    margin: 10px 0;
    border-radius: 0 6px 6px 0;
    font-size: 0.9em;
    color: #6c757d;
}

.thinking-process .thinking-header {
    font-weight: 600;
    color: #495057;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    cursor: pointer;
}

.thinking-process .thinking-content {
    line-height: 1.5;
}

.thinking-process.collapsed .thinking-content {
    display: none;
}
</style>
{% endblock %}

{% block content %}
<div class="chat-page-content">
    <div class="chat-container" id="chatContainer">
        <!-- 聊天侧边栏展开触发器 -->
        <div class="sidebar-trigger-chat" id="sidebarTriggerChat" title="显示对话列表">
            <i class="bi bi-chat-dots"></i>
        </div>
        
        <!-- 左侧边栏 - 对话历史 -->
        <div class="chat-sidebar" id="chatSidebar">
            <div class="sidebar-header">
                <button class="btn btn-primary w-100" id="newChatBtn">
                    <i class="bi bi-plus"></i> 新建对话
                </button>
            </div>
            
            <div class="sidebar-search">
                <div class="search-input-wrapper">
                    <i class="bi bi-search search-icon"></i>
                    <input type="text" class="form-control search-input" placeholder="搜索对话..." id="conversationSearch">
                </div>
            </div>
            
            <div class="sidebar-content">
                <div class="conversation-list" id="conversationList">
                    <!-- 对话列表将在这里动态加载 -->
                    <div class="loading-conversations text-center py-3">
                        <div class="spinner-border spinner-border-sm" role="status"></div>
                        <small class="text-muted d-block mt-2">加载对话中...</small>
                    </div>
                </div>
            </div>
            
            <div class="sidebar-footer">
                <button class="btn btn-outline-secondary btn-sm w-100" id="toggleSidebar">
                    <i class="bi bi-chevron-left"></i> 收起
                </button>
            </div>
        </div>
        
        <!-- 主聊天区域 -->
        <div class="chat-main">
            <!-- 聊天头部 -->
            <div class="chat-header">
                <div class="d-flex align-items-center position-relative">
                    <div class="d-flex align-items-center">
                        <button class="btn btn-outline-secondary btn-sm me-3" id="showSidebar">
                            <i class="bi bi-list"></i>
                        </button>
                        <div>
                            <h5 class="mb-0 editable-title" id="currentChatTitle" onclick="startEditTitle()" title="点击编辑标题">
                                智能问答
                                <i class="bi bi-pencil-square edit-icon"></i>
                            </h5>
                            <input type="text" class="form-control form-control-sm title-editor" id="titleEditor" style="display: none;" maxlength="50">
                        </div>
                    </div>
                    <div class="d-flex gap-2 align-items-center ms-auto">
                        {% if current_user.role.value in ['admin', 'tester'] %}
                        <button class="btn btn-outline-info btn-sm" id="debugBtn" title="调试模式">
                            <i class="bi bi-bug me-1"></i>调试
                        </button>
                        {% endif %}
                        <button class="btn btn-outline-secondary btn-sm" id="settingsBtn">
                            <i class="bi bi-gear me-1"></i>设置
                        </button>
                    </div>
                </div>
            </div>

            <!-- 分享对话模态框 -->
            <div class="share-conversation-modal" id="shareConversationModal">
                <div class="share-conversation-content">
                    <div class="share-conversation-header">
                        <h3><i class="bi bi-share"></i> 分享对话到论坛</h3>
                        <button class="close-modal" onclick="closeShareConversationModal()">&times;</button>
                    </div>
                    
                    <form id="shareConversationForm" style="padding: 20px 28px;">
                        <div class="form-group">
                            <label for="shareConversationTitle">对话标题</label>
                            <input type="text" class="form-control" id="shareConversationTitle" readonly>
                            <small class="text-muted">当前对话标题（无法修改）</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="shareConversationDescription">分享描述 *</label>
                            <textarea class="form-control" id="shareConversationDescription" rows="3" 
                                     placeholder="简单描述一下这个对话的内容和亮点..." maxlength="140"></textarea>
                            <div class="char-counter" id="shareDescriptionCharCounter">0/140</div>
                            <small class="text-muted">向大家介绍这个对话的精彩之处</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="shareConversationTags">标签</label>
                            <input type="text" class="form-control" id="shareConversationTags" 
                                   placeholder="输入标签，用逗号分隔，如：编程,创意写作,问题解答">
                            <small class="text-muted">添加相关标签帮助其他用户发现你的分享（可选）</small>
                        </div>
                        
                        <div class="form-group">
                            <label>对话统计</label>
                            <div class="conversation-stats">
                                <span class="stat-item">
                                    <i class="bi bi-chat-dots"></i>
                                    <span id="shareConversationMessageCount">-</span> 条消息
                                </span>
                                <span class="stat-item">
                                    <i class="bi bi-robot"></i>
                                    <span id="shareConversationModel">-</span>
                                </span>
                                <span class="stat-item">
                                    <i class="bi bi-clock"></i>
                                    <span id="shareConversationTime">-</span>
                                </span>
                            </div>
                        </div>
                        
                        <div class="share-conversation-actions">
                            <button type="button" class="btn btn-secondary" onclick="closeShareConversationModal()">取消</button>
                            <button type="submit" class="btn btn-primary" id="submitShareBtn">
                                <i class="bi bi-share"></i> 分享到论坛
                            </button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- 调试面板 -->
            <div class="debug-panel" id="debugPanel" style="display: none;">
                <div class="debug-header">
                    <h6 class="mb-0">
                        <i class="bi bi-bug"></i> 调试信息
                    </h6>
                    <div class="debug-controls">
                        <button class="btn btn-outline-secondary btn-sm" id="clearDebugBtn">
                            <i class="bi bi-trash me-1"></i>清空
                        </button>
                        <button class="btn btn-outline-secondary btn-sm" id="closeDebugBtn">
                            <i class="bi bi-x me-1"></i>关闭
                        </button>
                    </div>
                </div>
                <div class="debug-content">
                    <div class="debug-tabs">
                        <button class="debug-tab active" data-tab="model">模型参数</button>
                        <button class="debug-tab" data-tab="context">上下文</button>
                        <button class="debug-tab" data-tab="langchain">LangChain</button>
                        <button class="debug-tab" data-tab="database">数据库</button>
                        <button class="debug-tab" data-tab="system">系统</button>
                    </div>
                    <div class="debug-tab-content">
                        <div class="debug-tab-pane active" id="debug-model">
                            <div class="debug-info" id="debugModel">
                                <div class="text-muted text-center py-3">模型参数信息将在这里显示</div>
                            </div>
                        </div>
                        <div class="debug-tab-pane" id="debug-context">
                            <div class="debug-info" id="debugContext">
                                <div class="text-muted text-center py-3">API交互信息将在这里显示</div>
                            </div>
                        </div>
                        <div class="debug-tab-pane" id="debug-langchain">
                            <div class="debug-info" id="debugLangchain">
                                <div class="text-muted text-center py-3">LangChain处理信息将在这里显示</div>
                            </div>
                        </div>
                        <div class="debug-tab-pane" id="debug-database">
                            <div class="debug-info" id="debugDatabase">
                                <div class="text-muted text-center py-3">数据库信息将在这里显示</div>
                            </div>
                        </div>
                        <div class="debug-tab-pane" id="debug-system">
                            <div class="debug-info" id="debugSystem">
                                <div class="text-muted text-center py-3">系统状态信息</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 聊天消息区域 -->
            <div class="chat-messages-container">
                <div class="chat-messages" id="chatMessages">
                    <div class="welcome-message" id="welcomeMessage">
                        <i class="bi bi-chat-dots welcome-icon"></i>
                        <h4>开始新的对话</h4>
                        <p>向我提问任何问题，我会基于您的知识库为您提供准确的答案。</p>
                    </div>
                </div>
            </div>

            <!-- V0.3.0 紧凑型对话配置模态框 -->
            <div class="modal fade" id="configModal" tabindex="-1" aria-labelledby="configModalLabel" aria-hidden="true">
                <div class="modal-dialog modal-dialog-centered" style="max-width: 480px;">
                    <div class="modal-content">
                        <div class="modal-header py-2 px-3">
                            <h6 class="modal-title" id="configModalLabel">
                                <i class="bi bi-gear me-1"></i><span id="configModalTitle">对话参数配置</span>
                            </h6>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body px-3 py-2">
                            <form id="configForm">
                                <!-- 紧凑型布局：模型选择和温度 -->
                                <div class="row g-2 mb-3">
                                    <div class="col-7">
                                        <label class="form-label small mb-1">
                                            <i class="bi bi-cpu"></i> 模型
                                        </label>
                                        <select class="form-select form-select-sm" id="modelSelect" name="model_name">
                                            <option value="deepseek-chat">DeepSeek-V3 (快速)</option>
                                            <option value="deepseek-reasoner">DeepSeek-R1 (深度思考)</option>
                                        </select>
                                    </div>
                                    <div class="col-5">
                                        <label class="form-label small mb-1">
                                            <i class="bi bi-thermometer-half"></i> 温度
                                        </label>
                                        <select class="form-select form-select-sm" id="temperatureSelect" name="temperature">
                                            <option value="0.0">0 - 代码</option>
                                            <option value="1.0" selected>1.0 - 通用</option>
                                            <option value="1.5">1.5 - 创意</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- 输出长度 -->
                                <div class="mb-3">
                                    <label class="form-label small mb-1">
                                        <i class="bi bi-textarea-resize"></i> 输出长度
                                    </label>
                                    <div class="d-flex gap-2" id="maxTokensRadioGroup">
                                        <!-- 动态填充单选按钮 -->
                                    </div>
                                </div>

                                <!-- 快速模式选项 -->
                                <div class="mb-3">
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="checkbox" id="enableThinking" />
                                        <label class="form-check-label small" for="enableThinking">
                                            显示思考过程 (仅R1)
                                        </label>
                                    </div>
                                </div>

                                <!-- 初始提示词（可折叠） -->
                                <div class="mb-3">
                                    <div class="d-flex align-items-center mb-1">
                                        <label class="form-label small mb-0 me-2">
                                            <i class="bi bi-chat-square-text"></i> 初始提示词
                                        </label>
                                        <button type="button" class="btn btn-link btn-sm p-0 text-decoration-none" 
                                                data-bs-toggle="collapse" data-bs-target="#promptCollapse" 
                                                aria-expanded="false" aria-controls="promptCollapse">
                                            <i class="bi bi-chevron-down" id="promptToggleIcon"></i>
                                        </button>
                                    </div>
                                    <div class="collapse" id="promptCollapse">
                                        <textarea class="form-control form-control-sm" id="systemPrompt" name="system_prompt" 
                                                 rows="3" maxlength="2000" 
                                                 placeholder="设置AI角色，如：你是专业技术顾问..."></textarea>
                                        <div class="form-text small">
                                            <span id="promptCharCount">0</span>/2000 字符
                                        </div>
                                    </div>
                                </div>

                                <!-- 配置预览 -->
                                <div class="alert alert-light py-2 px-2 mb-0" id="configPreview">
                                    <!-- 动态生成配置预览 -->
                                </div>
                            </form>
                        </div>
                        <div class="modal-footer py-2 px-3">
                            <button type="button" class="btn btn-outline-secondary btn-sm" data-bs-dismiss="modal">
                                取消
                            </button>
                            <button type="button" class="btn btn-primary btn-sm" id="saveConfigBtn">
                                <span id="saveConfigBtnText">开始对话</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 输入区域 -->
            <div class="chat-input-container">
                <!-- 快捷操作 - V0.3.0 移除知识库选择 -->
                <div class="chat-controls">
                    <div class="quick-actions">
                        <button class="btn btn-outline-secondary btn-sm" onclick="insertQuickText('请帮我总结一下')">
                            <i class="bi bi-lightning me-1"></i>总结
                        </button>
                        <button class="btn btn-outline-secondary btn-sm" onclick="insertQuickText('请详细解释')">
                            <i class="bi bi-question-circle me-1"></i>解释
                        </button>
                        <button class="btn btn-outline-secondary btn-sm" onclick="insertQuickText('请举个例子')">
                            <i class="bi bi-lightbulb me-1"></i>举例
                        </button>
                    </div>
                </div>
                
                <!-- 输入框 - V0.3.0 调高输入框 -->
                <form id="chatForm" class="chat-input-form">
                    <div class="input-wrapper">
                        <textarea class="chat-input" id="messageInput" placeholder="输入您的问题..." 
                                 rows="3" style="min-height: 80px;"></textarea>
                        <button type="submit" class="send-btn" id="sendBtn" disabled>
                            <i class="bi bi-send"></i>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<script>
let currentConversationId = null;
let isLoading = false;
let conversations = [];

// 调试功能相关变量
let debugMode = false;
let debugData = {};
let currentDebugTab = 'model';

// 第一个DOMContentLoaded已移除 - 避免重复初始化

// 检查LangChain状态
async function checkLangChainStatus() {
    try {
        const response = await fetch('/api/langchain/config');
        const data = await response.json();
        
        if (data.success && data.config.enabled) {
            // LangChain标识已移除，只保留调试信息
            addDebugEntry('system', 'LangChain已启用', 'success');
        }
    } catch (error) {
        console.error('检查LangChain状态失败:', error);
    }
}

// 初始化调试功能
function initializeDebugFeatures() {
    // 调试按钮事件
    // 调试按钮可能不存在（非管理员/测试员）
const debugBtn = document.getElementById('debugBtn');
if (debugBtn) {
    debugBtn.addEventListener('click', toggleDebugMode);
}
document.getElementById('closeDebugBtn').addEventListener('click', closeDebugPanel);
document.getElementById('clearDebugBtn').addEventListener('click', clearDebugLog);
    
    // 调试标签切换
    document.querySelectorAll('.debug-tab').forEach(tab => {
        tab.addEventListener('click', function() {
            switchDebugTab(this.dataset.tab);
        });
    });
}

// V0.3.0 对话配置功能 - V0.3.1 修复默认配置
let currentConfig = {
    model_name: 'deepseek-chat',
    temperature: 1.0,
    max_tokens: 4000,
    system_prompt: ''
};

let configModalMode = 'edit'; // 'create' 或 'edit'

// V0.3.1 添加：确保默认配置正确初始化
function ensureDefaultConfig() {
    if (!currentConfig || typeof currentConfig.temperature === 'undefined') {
        console.log('[配置] 修复默认配置');
        currentConfig = {
            model_name: 'deepseek-chat',
            temperature: 1.0,
            max_tokens: 4000,
            system_prompt: ''
        };
    }
    console.log('[配置] 当前配置状态:', currentConfig);
}

// V0.3.1 添加：测试配置功能
function testConfig() {
    console.log('[测试] 开始测试配置功能');
    
    const temperatureSelect = document.getElementById('temperatureSelect');
    const modelSelect = document.getElementById('modelSelect');
    const systemPrompt = document.getElementById('systemPrompt');
    
    console.log('[测试] 温度选择器值:', temperatureSelect ? temperatureSelect.value : '未找到');
    console.log('[测试] 模型选择器值:', modelSelect ? modelSelect.value : '未找到');
    console.log('[测试] 系统提示词元素:', systemPrompt ? '存在' : '未找到');
    console.log('[测试] 输出长度值:', getMaxTokensValue ? getMaxTokensValue() : '函数未找到');
    
    // 测试温度选择器的所有选项
    if (temperatureSelect) {
        console.log('[测试] 温度选择器选项详情:');
        for (let i = 0; i < temperatureSelect.options.length; i++) {
            const option = temperatureSelect.options[i];
            console.log(`  选项${i}: value="${option.value}", text="${option.text}", selected=${option.selected}`);
        }
        
        // 测试设置温度值
        console.log('[测试] 尝试设置温度为1.0');
        temperatureSelect.value = '1.0';
        console.log('[测试] 设置后，温度值:', temperatureSelect.value);
        console.log('[测试] 设置后，选中的索引:', temperatureSelect.selectedIndex);
    }
    
    // 测试当前配置
    console.log('[测试] 当前配置对象:', currentConfig);
    console.log('[测试] 当前对话ID:', currentConversationId);
    console.log('[测试] 配置模式:', configModalMode);
    
    console.log('[测试] 配置功能测试完成');
}

// V0.3.1 添加：修复温度选择器的函数
window.fixTemperatureSelect = function() {
    console.log('[修复] 开始修复温度选择器');
    
    const temperatureSelect = document.getElementById('temperatureSelect');
    if (!temperatureSelect) {
        console.error('[修复] 温度选择器不存在');
        return;
    }
    
    // 强制设置为1.0并触发事件
    temperatureSelect.value = '1.0';
    temperatureSelect.dispatchEvent(new Event('change'));
    
    console.log('[修复] 修复后温度值:', temperatureSelect.value);
    console.log('[修复] 修复后选中索引:', temperatureSelect.selectedIndex);
    
    // 如果还是不对，通过selectedIndex设置
    if (temperatureSelect.value !== '1.0') {
        for (let i = 0; i < temperatureSelect.options.length; i++) {
            if (temperatureSelect.options[i].value === '1.0') {
                temperatureSelect.selectedIndex = i;
                temperatureSelect.dispatchEvent(new Event('change'));
                console.log('[修复] 通过selectedIndex修复成功:', temperatureSelect.value);
                break;
            }
        }
    }
};

// V0.3.1 添加：测试调试功能的函数
window.testDebugFeatures = function() {
    console.log('[测试] 开始测试调试功能');
    
    // 测试DOM元素存在性
    const debugElements = [
        'debugPanel', 'debugModel', 'debugContext', 
        'debugLangchain', 'debugDatabase', 'debugSystem'
    ];
    
    debugElements.forEach(id => {
        const element = document.getElementById(id);
        console.log(`[测试] ${id}:`, element ? '✅ 存在' : '❌ 不存在');
    });
    
    // 测试调试模式切换
    console.log('[测试] 当前调试模式:', debugMode);
    
    // V0.3.1 修复：不自动开启调试模式，只提示用户如何手动开启
    if (!debugMode) {
        console.log('[测试] 调试模式未开启。如需测试调试功能，请手动点击调试按钮或调用 toggleDebugMode()');
        console.log('[测试] 跳过需要调试模式的测试项目');
        return; // 提前返回，不执行需要调试模式的测试
    }
    
    // 测试添加调试条目
    try {
        addDebugEntry('test', '这是一个测试调试条目', 'info');
        console.log('[测试] ✅ addDebugEntry函数正常工作');
    } catch (error) {
        console.error('[测试] ❌ addDebugEntry函数出错:', error);
    }
    
    // 测试清空调试日志
    try {
        clearDebugLog();
        console.log('[测试] ✅ clearDebugLog函数正常工作');
    } catch (error) {
        console.error('[测试] ❌ clearDebugLog函数出错:', error);
    }
    
    console.log('[测试] 调试功能测试完成');
};

// V0.3.1 添加：测试配置模态框安全性的函数
window.testConfigModalSafety = function() {
    console.log('[测试] 开始测试配置模态框安全性');
    
    // 测试在模态框关闭后调用各种函数
    console.log('[测试] 测试模态框关闭后的函数安全性');
    
    try {
        updateConfigPreview();
        console.log('[测试] ✅ updateConfigPreview: 安全处理了空元素');
    } catch (error) {
        console.error('[测试] ❌ updateConfigPreview: 出现错误:', error);
    }
    
    try {
        updateCharCount();
        console.log('[测试] ✅ updateCharCount: 安全处理了空元素');
    } catch (error) {
        console.error('[测试] ❌ updateCharCount: 出现错误:', error);
    }
    
    try {
        const maxTokens = getMaxTokensValue();
        console.log('[测试] ✅ getMaxTokensValue: 返回值', maxTokens);
    } catch (error) {
        console.error('[测试] ❌ getMaxTokensValue: 出现错误:', error);
    }
    
    try {
        onModelChange();
        console.log('[测试] ✅ onModelChange: 安全处理了空元素');
    } catch (error) {
        console.error('[测试] ❌ onModelChange: 出现错误:', error);
    }
    
    console.log('[测试] 配置模态框安全性测试完成');
};

// V0.3.1 添加：供用户手动测试的函数
window.testConfigSave = async function() {
    console.log('[手动测试] 开始测试配置保存功能');
    
    try {
        // 确保配置正确
        ensureDefaultConfig();
        
        // 打开配置模态框
        await openConfigModal();
        
        console.log('[手动测试] 配置模态框已打开');
        console.log('[手动测试] 当前配置:', currentConfig);
        console.log('[手动测试] 请手动调整参数并点击保存按钮测试');
        console.log('[手动测试] 或者调用 window.testAutoSave() 自动测试保存功能');
        
    } catch (error) {
        console.error('[手动测试] 测试失败:', error);
    }
};

// V0.3.1 添加：自动测试保存功能
window.testAutoSave = async function() {
    console.log('[自动测试] 开始自动测试配置保存');
    
    try {
        // 确保有当前对话
        if (!currentConversationId) {
            console.warn('[自动测试] 没有当前对话，请先开始一个对话');
            return;
        }
        
        // 模拟保存配置
        const testConfig = {
            model_name: 'deepseek-chat',
            temperature: 1.0,
            max_tokens: 4000,
            system_prompt: '测试提示词'
        };
        
        console.log('[自动测试] 准备保存配置:', testConfig);
        
        const response = await fetch(`/api/conversations/${currentConversationId}/config`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(testConfig)
        });
        
        const data = await response.json();
        
        if (data.success) {
            console.log('[自动测试] ✅ 配置保存成功:', data);
        } else {
            console.error('[自动测试] ❌ 配置保存失败:', data);
        }
        
    } catch (error) {
        console.error('[自动测试] 测试异常:', error);
    }
};

// 初始化配置功能
function initializeConfigFeatures() {
    console.log('[配置] 初始化配置功能');
    
    // V0.3.1 修复：确保默认配置正确初始化
    ensureDefaultConfig();
    
    // 设置按钮事件
    document.getElementById('settingsBtn').addEventListener('click', openConfigModal);
    
    // 保存配置按钮事件
    document.getElementById('saveConfigBtn').addEventListener('click', saveConversationConfig);
    
    // 模型切换事件
    document.getElementById('modelSelect').addEventListener('change', onModelChange);
    
    // 系统提示词字符计数
    document.getElementById('systemPrompt').addEventListener('input', updateCharCount);
    
    // 配置预览更新
    ['modelSelect', 'temperatureSelect', 'systemPrompt'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('change', updateConfigPreview);
            element.addEventListener('input', updateConfigPreview);
        }
    });
    
    // 初始化输出长度单选按钮
    initMaxTokensRadio();
    
    // 初始化折叠提示词
    initPromptCollapse();
    
    // V0.3.1 修复：初始化时设置思考过程复选框状态
    onModelChange();
    
    console.log('[配置] 配置功能初始化完成');
}

// 初始化输出长度单选按钮
function initMaxTokensRadio() {
    const container = document.getElementById('maxTokensRadioGroup');
    if (!container) return;
    
    // 默认选项（V3模型）
    updateMaxTokensOptions('deepseek-chat');
}

// 初始化折叠提示词
function initPromptCollapse() {
    const promptCollapse = document.getElementById('promptCollapse');
    const toggleIcon = document.getElementById('promptToggleIcon');
    
    if (promptCollapse && toggleIcon) {
        promptCollapse.addEventListener('show.bs.collapse', () => {
            toggleIcon.className = 'bi bi-chevron-up';
        });
        
        promptCollapse.addEventListener('hide.bs.collapse', () => {
            toggleIcon.className = 'bi bi-chevron-down';
        });
    }
}

// 打开配置模态框（修改现有对话）
async function openConfigModal() {
    try {
        console.log('[配置] 打开配置模态框, 当前对话ID:', currentConversationId);
        
        // V0.3.1 修复：根据是否有对话ID来决定模式
        if (currentConversationId) {
            // 有对话ID，编辑模式
            configModalMode = 'edit';
            document.getElementById('configModalTitle').textContent = '修改对话参数';
            document.getElementById('saveConfigBtnText').textContent = '保存配置';
            
            console.log('[配置] 编辑模式，尝试获取对话配置, ID:', currentConversationId);
            
            try {
                // 获取当前对话的真实配置
                const response = await fetch(`/api/conversations/${currentConversationId}/config`);
                const data = await response.json();
                
                if (data.success) {
                    console.log('[配置] 获取到对话的真实配置:', data.config);
                    currentConfig = data.config;
                } else {
                    console.warn('[配置] 获取对话配置失败，使用默认配置:', data.message);
                    ensureDefaultConfig();
                }
            } catch (fetchError) {
                console.error('[配置] 获取配置API调用失败:', fetchError);
                ensureDefaultConfig();
            }
        } else {
            // 没有对话ID，新建模式
            configModalMode = 'create';
            document.getElementById('configModalTitle').textContent = '新建对话 - 参数设置';
            document.getElementById('saveConfigBtnText').textContent = '开始对话';
            
            console.log('[配置] 新建模式，使用默认配置');
            ensureDefaultConfig();
        }
        
        // 填充配置到表单
        fillConfigForm(currentConfig);
        
        // 显示模态框
        const modal = new bootstrap.Modal(document.getElementById('configModal'));
        modal.show();
        
    } catch (error) {
        console.error('[配置] 打开配置模态框失败:', error);
        
        // 出错时使用默认配置和新建模式
        configModalMode = 'create';
        document.getElementById('configModalTitle').textContent = '新建对话 - 参数设置';
        document.getElementById('saveConfigBtnText').textContent = '开始对话';
        
        ensureDefaultConfig();
        fillConfigForm(currentConfig);
        
        const modal = new bootstrap.Modal(document.getElementById('configModal'));
        modal.show();
    }
}

// 填充配置表单 - 适应新的紧凑型界面
function fillConfigForm(config) {
    console.log('[配置] 填充表单配置:', config);
    
    // 1. 设置模型选择器
    const modelSelect = document.getElementById('modelSelect');
    modelSelect.value = config.model_name || 'deepseek-chat';
    console.log('[配置] 设置模型:', modelSelect.value);
    
    // 2. 设置温度选择器 - V0.3.1 修复
    const temperatureSelect = document.getElementById('temperatureSelect');
    let temperatureValue = '1.0'; // 强制默认值
    
    if (config.temperature !== undefined && config.temperature !== null) {
        temperatureValue = config.temperature.toString();
    }
    
    console.log('[配置] 准备设置温度值:', temperatureValue);
    console.log('[配置] 温度选择器当前选项:');
    for (let i = 0; i < temperatureSelect.options.length; i++) {
        console.log(`  选项${i}: value="${temperatureSelect.options[i].value}", text="${temperatureSelect.options[i].text}"`);
    }
    
    // V0.3.1 修复：延迟设置，确保DOM已准备好且模态框仍然可见
    setTimeout(() => {
        // 检查温度选择器是否仍然可访问（模态框未关闭）
        const currentTemperatureSelect = document.getElementById('temperatureSelect');
        if (!currentTemperatureSelect) {
            console.log('[配置] 模态框已关闭，跳过延迟的温度设置');
            return;
        }
        
        currentTemperatureSelect.value = temperatureValue;
        console.log('[配置] 温度值设置后:', currentTemperatureSelect.value);
        
        // 如果设置失败，强制选择第一个包含1.0的选项
        if (currentTemperatureSelect.value !== temperatureValue) {
            console.warn('[配置] 温度值设置失败，尝试通过索引设置');
            for (let i = 0; i < currentTemperatureSelect.options.length; i++) {
                if (currentTemperatureSelect.options[i].value === temperatureValue) {
                    currentTemperatureSelect.selectedIndex = i;
                    console.log('[配置] 通过索引设置温度成功:', currentTemperatureSelect.value);
                    break;
                }
            }
        }
        
        // 只有当所有必要元素都存在时才触发change事件
        if (document.getElementById('configPreview')) {
            currentTemperatureSelect.dispatchEvent(new Event('change'));
            console.log('[配置] 延迟设置完成，已触发change事件');
        } else {
            console.log('[配置] 模态框已关闭，跳过change事件触发');
        }
    }, 50);
    
    // 3. 设置系统提示词
    const systemPrompt = document.getElementById('systemPrompt');
    systemPrompt.value = config.system_prompt || '';
    console.log('[配置] 设置系统提示词长度:', systemPrompt.value.length);
    
    // 4. 更新输出长度选项
    updateMaxTokensOptions(config.model_name || 'deepseek-chat');
    setMaxTokensValue(config.max_tokens || 4000);
    
    // 5. 更新字符计数和预览
    updateCharCount();
    updateConfigPreview();
    
    console.log('[配置] 配置表单填充完成');
}

// 模型变化时更新输出长度选项 - V0.3.1 修复：添加思考过程自动控制和温度控制
function onModelChange() {
    const modelSelect = document.getElementById('modelSelect');
    if (!modelSelect) {
        console.warn('[配置] onModelChange: modelSelect元素不存在');
        return;
    }
    
    const modelName = modelSelect.value;
    const enableThinkingCheckbox = document.getElementById('enableThinking');
    const temperatureSelect = document.getElementById('temperatureSelect');
    
    // V0.3.1 修复：自动控制思考过程显示选项
    if (enableThinkingCheckbox) {
        if (modelName === 'deepseek-reasoner') {
            // R1模型：自动启用思考过程显示
            enableThinkingCheckbox.checked = true;
            enableThinkingCheckbox.disabled = false;
            console.log('[配置] 选择R1模型，自动启用思考过程显示');
        } else {
            // 其他模型：禁用思考过程显示选项
            enableThinkingCheckbox.checked = false;
            enableThinkingCheckbox.disabled = true;
            console.log('[配置] 选择非R1模型，禁用思考过程显示');
        }
    }
    
    // V0.3.1 修复：温度参数控制逻辑
    if (temperatureSelect) {
        if (modelName === 'deepseek-reasoner') {
            // R1模型：禁用温度选择，R1有固定推理温度
            temperatureSelect.disabled = true;
            console.log('[配置] 选择R1模型，禁用温度选择');
        } else {
            // V3模型：启用温度选择，默认为1.0
            temperatureSelect.disabled = false;
            temperatureSelect.value = '1.0';
            console.log('[配置] 选择V3模型，启用温度选择，默认为1.0');
        }
    }
    
    updateMaxTokensOptions(modelName);
    updateConfigPreview();
}

// 更新输出长度选项 - 新的单选按钮版本 - V0.3.1 修复：增强安全检查
function updateMaxTokensOptions(modelName) {
    const container = document.getElementById('maxTokensRadioGroup');
    if (!container) {
        console.warn('[配置] updateMaxTokensOptions: maxTokensRadioGroup元素不存在');
        return;
    }
    
    container.innerHTML = '';
    
    let options = [];
    if (modelName === 'deepseek-chat') {
        options = [
            { value: '4000', label: '4K' },
            { value: '8000', label: '8K' }
        ];
    } else if (modelName === 'deepseek-reasoner') {
        options = [
            { value: '32000', label: '32K' },
            { value: '64000', label: '64K' }
        ];
    }
    
    options.forEach((option, index) => {
        const radioHtml = `
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="max_tokens" 
                       id="maxTokens${option.value}" value="${option.value}" 
                       ${index === 0 ? 'checked' : ''} onchange="updateConfigPreview()">
                <label class="form-check-label small" for="maxTokens${option.value}">
                    ${option.label}
                </label>
            </div>
        `;
        container.innerHTML += radioHtml;
    });
}

// 设置输出长度值
function setMaxTokensValue(value) {
    const radio = document.querySelector(`input[name="max_tokens"][value="${value}"]`);
    if (radio) {
        radio.checked = true;
    }
}

// 获取选中的输出长度值 - V0.3.1 修复：添加安全检查
function getMaxTokensValue() {
    try {
        const radio = document.querySelector('input[name="max_tokens"]:checked');
        return radio ? parseInt(radio.value) : 4000;
    } catch (error) {
        console.warn('[配置] getMaxTokensValue: 获取输出长度值失败，返回默认值');
        return 4000;
    }
}

// 更新字符计数 - V0.3.1 修复：添加元素存在性检查
function updateCharCount() {
    const systemPrompt = document.getElementById('systemPrompt');
    const charCountSpan = document.getElementById('promptCharCount');
    
    if (!systemPrompt || !charCountSpan) {
        console.warn('[配置] updateCharCount: 必要元素不存在');
        return;
    }
    
    const charCount = systemPrompt.value.length;
    charCountSpan.textContent = charCount;
    
    // 字符数警告
    if (charCount > 1800) {
        charCountSpan.className = 'text-warning';
    } else if (charCount > 1950) {
        charCountSpan.className = 'text-danger';
    } else {
        charCountSpan.className = 'text-muted';
    }
}

// 更新配置预览 - 紧凑版本 - V0.3.1 修复：添加元素存在性检查
function updateConfigPreview() {
    // V0.3.1 修复：检查必要元素是否存在
    const modelSelect = document.getElementById('modelSelect');
    const temperatureSelect = document.getElementById('temperatureSelect');
    const systemPromptElement = document.getElementById('systemPrompt');
    const configPreview = document.getElementById('configPreview');
    
    if (!modelSelect || !temperatureSelect || !systemPromptElement || !configPreview) {
        console.warn('[配置] updateConfigPreview: 必要元素不存在，可能模态框已关闭');
        return;
    }
    
    const modelName = modelSelect.value;
    const temperature = temperatureSelect.value;
    const maxTokens = getMaxTokensValue();
    const systemPrompt = systemPromptElement.value;
    
    const modelDisplayMap = {
        'deepseek-chat': 'DeepSeek-V3',
        'deepseek-reasoner': 'DeepSeek-R1'
    };
    
    const temperatureDisplayMap = {
        '0.0': '代码',
        '1.0': '通用',
        '1.5': '创意'
    };
    
    const previewHtml = `
        <div class="d-flex justify-content-between small">
            <span><strong>${modelDisplayMap[modelName] || modelName}</strong></span>
            <span>温度: ${temperatureDisplayMap[temperature] || temperature}</span>
            <span>输出: ${(maxTokens/1000).toFixed(0)}K</span>
            <span>${systemPrompt ? '✓ 提示词' : '默认'}</span>
        </div>
    `;
    
    configPreview.innerHTML = previewHtml;
}

// 保存对话配置 - 更新以支持新建和修改模式
async function saveConversationConfig() {
    try {
        const modelSelect = document.getElementById('modelSelect');
        const temperatureSelect = document.getElementById('temperatureSelect');
        const systemPrompt = document.getElementById('systemPrompt');
        
        console.log('[配置] 准备保存配置');
        console.log('[配置] 模型选择器值:', modelSelect.value);
        console.log('[配置] 温度选择器值:', temperatureSelect.value);
        console.log('[配置] 输出长度值:', getMaxTokensValue());
        
        const config = {
            model_name: modelSelect.value,
            temperature: parseFloat(temperatureSelect.value),
            max_tokens: getMaxTokensValue(),
            system_prompt: systemPrompt.value.trim() || null
        };
        
        console.log('[配置] 准备保存的配置对象:', config);
        
        // 验证配置
        if (!config.model_name) {
            showAlert('请选择模型', 'error');
            return;
        }
        
        if (isNaN(config.temperature)) {
            showAlert('温度参数无效', 'error');
            return;
        }
        
        if (!config.max_tokens || config.max_tokens <= 0) {
            showAlert('输出长度参数无效', 'error');
            return;
        }
        
        // 验证系统提示词长度
        if (config.system_prompt && config.system_prompt.length > 2000) {
            showAlert('系统提示词不能超过2000字符', 'error');
            return;
        }
        
        if (configModalMode === 'create') {
            // 新建对话模式
            currentConfig = config;
            console.log('[配置] 新建对话模式，保存配置:', currentConfig);
            
            // V0.3.1 修复：立即显示模型参数调试信息
            if (debugMode) {
                updateModelParamsDebug({
                    model_name: config.model_name,
                    temperature: config.temperature,
                    max_tokens: config.max_tokens,
                    has_system_prompt: !!config.system_prompt,
                    system_prompt_length: config.system_prompt ? config.system_prompt.length : 0
                });
            }
            
            // 关闭模态框并开始新对话
            bootstrap.Modal.getInstance(document.getElementById('configModal')).hide();
            doStartNewConversation();
            
        } else if (configModalMode === 'edit') {
            console.log('[配置] 编辑模式，当前对话ID:', currentConversationId);
            
            if (currentConversationId) {
                // 有对话ID，更新现有对话配置
                const response = await fetch(`/api/conversations/${currentConversationId}/config`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(config)
                });
                
                console.log('[配置] API响应状态:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('[配置] API响应数据:', data);
                
                if (data.success) {
                    currentConfig = config;
                    console.log('[配置] 配置保存成功，更新currentConfig:', currentConfig);
                    
                    // V0.3.1 修复：配置更新后立即显示模型参数调试信息
                    if (debugMode) {
                        updateModelParamsDebug({
                            model_name: config.model_name,
                            temperature: config.temperature,
                            max_tokens: config.max_tokens,
                            has_system_prompt: !!config.system_prompt,
                            system_prompt_length: config.system_prompt ? config.system_prompt.length : 0
                        });
                    }
                    
                    bootstrap.Modal.getInstance(document.getElementById('configModal')).hide();
                    showAlert('配置保存成功', 'success');
                } else {
                    console.error('[配置] 保存失败:', data.message);
                    showAlert(data.message || '保存配置失败', 'error');
                }
            } else {
                // 编辑模式但没有对话ID，转为新建模式
                console.log('[配置] 编辑模式但无对话ID，转为新建对话');
                currentConfig = config;
                
                if (debugMode) {
                    updateModelParamsDebug({
                        model_name: config.model_name,
                        temperature: config.temperature,
                        max_tokens: config.max_tokens,
                        has_system_prompt: !!config.system_prompt,
                        system_prompt_length: config.system_prompt ? config.system_prompt.length : 0
                    });
                }
                
                bootstrap.Modal.getInstance(document.getElementById('configModal')).hide();
                doStartNewConversation();
            }
        } else {
            console.error('[配置] 未知的配置模式:', configModalMode);
            showAlert('保存配置失败：未知模式', 'error');
        }
        
    } catch (error) {
        console.error('[配置] 保存配置异常:', error);
        showAlert(`保存配置失败: ${error.message}`, 'error');
    }
}

// 切换调试模式
function toggleDebugMode() {
    debugMode = !debugMode;
    const debugPanel = document.getElementById('debugPanel');
    const chatMain = document.querySelector('.chat-main');
    const debugBtn = document.getElementById('debugBtn');
    
    if (debugMode) {
        debugPanel.style.display = 'flex';
        chatMain.classList.add('debug-mode');
        if (debugBtn) {
            debugBtn.classList.add('active');
        }
        addDebugEntry('system', '调试模式已开启', 'info');
        loadSystemInfo();
        
        // V0.3.1 修复：开启调试模式时立即显示当前对话的模型参数
        if (currentConfig) {
            updateModelParamsDebug({
                model_name: currentConfig.model_name,
                temperature: currentConfig.temperature,
                max_tokens: currentConfig.max_tokens,
                has_system_prompt: !!currentConfig.system_prompt,
                system_prompt_length: currentConfig.system_prompt ? currentConfig.system_prompt.length : 0
            });
        }
    } else {
        debugPanel.style.display = 'none';
        chatMain.classList.remove('debug-mode');
        if (debugBtn) {
            debugBtn.classList.remove('active');
        }
    }
}

// 关闭调试面板
function closeDebugPanel() {
    debugMode = false;
    document.getElementById('debugPanel').style.display = 'none';
    document.querySelector('.chat-main').classList.remove('debug-mode');
    const debugBtn = document.getElementById('debugBtn');
    if (debugBtn) {
        debugBtn.classList.remove('active');
    }
}

// 清空调试日志 - V0.3.1 修复：清空所有调试标签页
function clearDebugLog() {
    // V0.3.1 修复：清空系统日志而不是不存在的debugLog
    const debugSystem = document.getElementById('debugSystem');
    if (debugSystem) {
        debugSystem.innerHTML = '<div class="text-muted text-center py-3">系统状态信息</div>';
    }
    
    const debugContext = document.getElementById('debugContext');
    if (debugContext) {
        debugContext.innerHTML = '<div class="text-muted text-center py-3">API交互信息将在这里显示</div>';
    }
    
    const debugLangchain = document.getElementById('debugLangchain');
    if (debugLangchain) {
        debugLangchain.innerHTML = '<div class="text-muted text-center py-3">LangChain处理信息将在这里显示</div>';
    }
    
    const debugDatabase = document.getElementById('debugDatabase');
    if (debugDatabase) {
        debugDatabase.innerHTML = '<div class="text-muted text-center py-3">数据库信息将在这里显示</div>';
    }
    
    const debugModel = document.getElementById('debugModel');
    if (debugModel) {
        debugModel.innerHTML = '<div class="text-muted text-center py-3">模型参数信息将在这里显示</div>';
    }
    
    debugData = {};
    console.log('[调试] 所有调试面板已清空');
}

// 切换调试标签
function switchDebugTab(tabName) {
    // 更新标签状态
    document.querySelectorAll('.debug-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    
    // 显示对应内容
    document.querySelectorAll('.debug-tab-pane').forEach(pane => {
        pane.classList.remove('active');
    });
    document.getElementById(`debug-${tabName}`).classList.add('active');
    
    currentDebugTab = tabName;
    
    // 如果切换到系统标签，加载系统信息
    if (tabName === 'system') {
        loadSystemInfo();
    }
    
    // 如果切换到数据库标签，加载数据库信息
    if (tabName === 'database') {
        loadDatabaseInfo();
    }
}

// 添加调试日志条目 - V0.3.1 修复：使用系统标签页显示日志
function addDebugEntry(type, message, level = 'info', data = null) {
    if (!debugMode) return;
    
    // V0.3.1 修复：使用系统标签页而不是不存在的debugLog元素
    const debugSystem = document.getElementById('debugSystem');
    if (!debugSystem) {
        console.warn('[调试] debugSystem元素不存在，无法添加调试条目');
        return;
    }
    
    const timestamp = new Date().toLocaleTimeString();
    
    // 如果是第一个条目，清空默认消息
    if (debugSystem.innerHTML.includes('系统状态信息')) {
        debugSystem.innerHTML = '<div class="mb-2"><strong>📋 系统日志</strong></div>';
    }
    
    const entry = document.createElement('div');
    entry.className = `debug-entry ${level} mb-2`;
    
    let content = `
        <div class="debug-entry-header">
            <span class="small text-muted">[${timestamp}]</span> 
            <span class="badge bg-${level === 'error' ? 'danger' : level === 'success' ? 'success' : 'primary'}">${type.toUpperCase()}</span>
        </div>
        <div class="debug-entry-content mt-1">${message}</div>
    `;
    
    if (data) {
        content += `<details class="mt-1"><summary class="small text-muted">详细数据</summary><div class="debug-json mt-1">${JSON.stringify(data, null, 2)}</div></details>`;
    }
    
    entry.innerHTML = content;
    debugSystem.appendChild(entry);
    
    // 限制条目数量，只保留最新的20条
    const entries = debugSystem.querySelectorAll('.debug-entry');
    if (entries.length > 20) {
        entries[1].remove(); // 保留标题，删除最旧的条目
    }
    
    // 滚动到底部
    debugSystem.scrollTop = debugSystem.scrollHeight;
}

// V0.3.1 重新设计上下文调试信息 - 展示完整API交互
function updateContextDebug(apiInteraction) {
    if (!debugMode) return;
    
    const debugContext = document.getElementById('debugContext');
    if (!debugContext) {
        console.warn('[调试] debugContext元素不存在');
        return;
    }
    
    const timestamp = new Date().toLocaleTimeString();
    
    if (!apiInteraction) {
        debugContext.innerHTML = `
            <div class="text-muted text-center py-3">
                发送消息后将显示API交互详情
            </div>
        `;
        return;
    }
    
    debugContext.innerHTML = `
        <div class="debug-entry success">
            <div class="debug-entry-header">📤 发送给API的请求 <span class="text-muted">${timestamp}</span></div>
            <div class="debug-entry-content">
                <div class="mb-2">
                    <strong>用户原始输入:</strong> 
                    <code style="background: #f8f9fa; padding: 2px 4px; border-radius: 3px;">
                        ${truncateText(apiInteraction.user_message, 100)}
                    </code>
                </div>
                
                <details class="mt-2">
                    <summary class="text-primary" style="cursor: pointer;">📋 完整请求JSON</summary>
                    <div class="debug-json mt-2" style="max-height: 300px; overflow-y: auto;">
                        ${JSON.stringify(apiInteraction.request, null, 2)}
                    </div>
                </details>
            </div>
        </div>
        
        <div class="debug-entry info mt-3">
            <div class="debug-entry-header">📥 API返回的响应</div>
            <div class="debug-entry-content">
                <div class="mb-2">
                    <strong>响应状态:</strong> 
                    <span class="badge ${apiInteraction.response_success ? 'bg-success' : 'bg-danger'}">
                        ${apiInteraction.response_success ? '成功' : '失败'}
                    </span>
                </div>
                
                ${apiInteraction.response_content ? `
                    <div class="mb-2">
                        <strong>AI回复内容预览:</strong><br>
                        <div style="background: #f8f9fa; padding: 8px; border-radius: 4px; border-left: 3px solid #007bff;">
                            ${truncateText(apiInteraction.response_content, 200)}
                        </div>
                    </div>
                ` : ''}
                
                ${apiInteraction.thinking_process ? `
                    <div class="mb-2">
                        <strong>R1思考过程:</strong> 
                        <span class="text-success">已检测到</span> 
                        (${apiInteraction.thinking_process.length} 字符)
                    </div>
                ` : ''}
                
                <details class="mt-2">
                    <summary class="text-primary" style="cursor: pointer;">📋 完整响应JSON</summary>
                    <div class="debug-json mt-2" style="max-height: 300px; overflow-y: auto;">
                        ${JSON.stringify(apiInteraction.response, null, 2)}
                    </div>
                </details>
                
                <div class="mt-2 text-muted small">
                    <strong>处理时间:</strong> ${apiInteraction.processing_time || '未知'}ms |
                    <strong>Token消耗:</strong> ${apiInteraction.token_usage || '未知'}
                </div>
            </div>
        </div>
    `;
}

// 文本截断函数
function truncateText(text, maxLength) {
    if (!text) return '无';
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
}

// 更新LangChain调试信息
function updateLangChainDebug(langchainInfo) {
    if (!debugMode) return;
    
    const debugLangchain = document.getElementById('debugLangchain');
    if (!debugLangchain) {
        console.warn('[调试] debugLangchain元素不存在');
        return;
    }
    
    debugLangchain.innerHTML = '';
    
    if (langchainInfo.enabled) {
        debugLangchain.innerHTML += `
            <div class="debug-entry success">
                <div class="debug-entry-header">LangChain状态</div>
                <div class="debug-entry-content">
                    <p><strong>状态:</strong> 已启用</p>
                    <p><strong>内存类型:</strong> ${langchainInfo.memory_type || '未知'}</p>
                    <p><strong>处理时间:</strong> ${langchainInfo.processing_time || '未知'}ms</p>
                </div>
            </div>
        `;
        
        if (langchainInfo.context_info) {
            debugLangchain.innerHTML += `
                <div class="debug-entry info">
                    <div class="debug-entry-header">上下文管理</div>
                    <div class="debug-json">${JSON.stringify(langchainInfo.context_info, null, 2)}</div>
                </div>
            `;
        }
        
        if (langchainInfo.processing_steps) {
            debugLangchain.innerHTML += `
                <div class="debug-entry">
                    <div class="debug-entry-header">处理步骤</div>
                    <div class="debug-entry-content">
                        ${langchainInfo.processing_steps.map(step => `<p>• ${step}</p>`).join('')}
                    </div>
                </div>
            `;
        }
    } else {
        debugLangchain.innerHTML = `
            <div class="debug-entry warning">
                <div class="debug-entry-header">LangChain状态</div>
                <div class="debug-entry-content">LangChain未启用，使用传统上下文管理</div>
            </div>
        `;
    }
}

// V0.3.1 重新设计模型参数调试信息显示
function updateModelParamsDebug(modelParams) {
    if (!debugMode) return;
    
    const debugModel = document.getElementById('debugModel');
    if (!debugModel) return;
    
    const timestamp = new Date().toLocaleTimeString();
    
    debugModel.innerHTML = `
        <div class="debug-entry success">
            <div class="debug-entry-header">🤖 当前对话模型配置</div>
            <div class="debug-entry-content">
                <table class="table table-sm table-borderless mb-0">
                    <tr><td width="30%"><strong>模型名称:</strong></td><td>${getModelDisplayName(modelParams.model_name)} <code>(${modelParams.model_name})</code></td></tr>
                    <tr><td><strong>温度参数:</strong></td><td>${getTemperatureDisplayName(modelParams.temperature)} <code>(${modelParams.temperature})</code></td></tr>
                    <tr><td><strong>最大输出:</strong></td><td><code>${modelParams.max_tokens}</code> tokens</td></tr>
                    <tr><td><strong>系统提示词:</strong></td><td>${modelParams.has_system_prompt ? `<span class="text-success">已设置</span> (${modelParams.system_prompt_length} 字符)` : '<span class="text-muted">未设置</span>'}</td></tr>
                    <tr><td><strong>更新时间:</strong></td><td><code>${timestamp}</code></td></tr>
                </table>
            </div>
        </div>
        
        <div class="debug-entry info mt-3">
            <div class="debug-entry-header">📊 模型特性说明</div>
            <div class="debug-entry-content">
                ${getModelDescription(modelParams.model_name)}
            </div>
        </div>
    `;
}

// 获取模型显示名称
function getModelDisplayName(modelName) {
    const modelNames = {
        'deepseek-chat': 'DeepSeek-V3',
        'deepseek-reasoner': 'DeepSeek-R1'
    };
    return modelNames[modelName] || modelName;
}

// 获取温度显示名称
function getTemperatureDisplayName(temperature) {
    const tempNames = {
        0: '代码生成',
        1.0: '通用对话',
        1.5: '创意写作'
    };
    return tempNames[temperature] || `自定义(${temperature})`;
}

// 获取模型特性说明
function getModelDescription(modelName) {
    const descriptions = {
        'deepseek-chat': `
            <p><strong>DeepSeek-V3</strong> - 高性能通用对话模型</p>
            <ul class="mb-0" style="font-size: 0.9em;">
                <li>支持4K/8K输出长度</li>
                <li>平衡的推理和创意能力</li>
                <li>适合日常对话、代码生成、文档写作</li>
                <li>响应速度快，成本较低</li>
            </ul>
        `,
        'deepseek-reasoner': `
            <p><strong>DeepSeek-R1</strong> - 深度推理思考模型</p>
            <ul class="mb-0" style="font-size: 0.9em;">
                <li>支持32K/64K超长输出</li>
                <li>具备深度思考和推理能力</li>
                <li>适合复杂问题分析、学术研究</li>
                <li>会显示完整的思考过程</li>
            </ul>
        `
    };
    return descriptions[modelName] || '<p>模型信息暂不可用</p>';
}

// 更新数据库调试信息
function updateDatabaseDebug(dbOperations) {
    if (!debugMode) return;
    
    // 在处理过程标签页显示数据库操作
    const debugProcess = document.getElementById('debug-process');
    if (!debugProcess) return;
    
    // 查找或创建数据库操作部分
    let dbSection = debugProcess.querySelector('.db-operations-section');
    if (!dbSection) {
        dbSection = document.createElement('div');
        dbSection.className = 'db-operations-section';
        dbSection.innerHTML = `
            <div class="debug-entry info">
                <div class="debug-entry-header">📊 数据库操作</div>
                <div class="db-operations-list"></div>
            </div>
        `;
        debugProcess.appendChild(dbSection);
    }
    
    const operationsList = dbSection.querySelector('.db-operations-list');
    
    // 渲染数据库操作
    dbOperations.forEach(op => {
        const opDiv = document.createElement('div');
        opDiv.className = `db-operation ${getOperationLevel(op.operation)}`;
        
        const timestamp = new Date(op.timestamp * 1000).toLocaleTimeString();
        let content = `<strong>[${timestamp}]</strong> ${getOperationDescription(op)}`;
        
        if (op.duration) {
            content += ` <span class="text-muted">(${op.duration.toFixed(3)}s)</span>`;
        }
        
        if (op.error) {
            content += `<br><span class="text-danger">错误: ${op.error}</span>`;
        }
        
        opDiv.innerHTML = content;
        operationsList.appendChild(opDiv);
    });
    
    // 滚动到底部
    operationsList.scrollTop = operationsList.scrollHeight;
}

// 获取操作级别样式
function getOperationLevel(operation) {
    const successOps = ['user_message_saved', 'save_ai_message_success', 'ai_message_queued_for_save'];
    const warningOps = ['message_already_exists', 'retry_scheduled'];
    const errorOps = ['save_ai_message_error', 'conversation_not_found', 'save_failed_final'];
    
    if (successOps.includes(operation)) return 'success';
    if (warningOps.includes(operation)) return 'warning';
    if (errorOps.includes(operation)) return 'error';
    return 'info';
}

// 获取操作描述
function getOperationDescription(op) {
    const descriptions = {
        'user_message_saved': '✅ 用户消息已保存',
        'ai_message_queued_for_save': '⏳ AI消息已加入保存队列',
        'save_ai_message_start': '🔄 开始保存AI消息',
        'save_ai_message_success': '✅ AI消息保存成功',
        'save_ai_message_error': '❌ AI消息保存失败',
        'conversation_not_found': '⚠️ 对话不存在',
        'message_already_exists': '⚠️ 消息已存在，跳过保存',
        'retry_scheduled': '🔄 安排重试保存',
        'save_failed_final': '💀 保存彻底失败',
        'rollback_error': '⚠️ 回滚失败',
        'stream_error': '❌ 流式处理错误'
    };
    
    let desc = descriptions[op.operation] || `📝 ${op.operation}`;
    
    if (op.ai_msg_id) {
        desc += ` (ID: ${op.ai_msg_id.substring(0, 8)}...)`;
    }
    
    if (op.retry_count > 0) {
        desc += ` [重试 ${op.retry_count}]`;
    }
    
    if (op.queue_size !== undefined) {
        desc += ` [队列: ${op.queue_size}]`;
    }
    
    return desc;
}

// 加载系统信息
async function loadSystemInfo() {
    if (!debugMode || currentDebugTab !== 'system') return;
    
    const debugSystem = document.getElementById('debugSystem');
    if (!debugSystem) {
        console.warn('[调试] debugSystem元素不存在');
        return;
    }
    
    debugSystem.innerHTML = '<div class="text-center py-3"><div class="spinner-border spinner-border-sm"></div> 加载中...</div>';
    
    try {
        // 获取LangChain配置
        const langchainResponse = await fetch('/api/langchain/config');
        const langchainData = await langchainResponse.json();
        
        // 获取对话统计
        const conversationsResponse = await fetch('/api/conversations');
        const conversationsData = await conversationsResponse.json();
        
        // 🔥 获取消息保存队列状态
        const messageSaveResponse = await fetch('/api/message_save_status');
        const messageSaveData = await messageSaveResponse.json();
        
        debugSystem.innerHTML = `
            <div class="debug-entry info">
                <div class="debug-entry-header">系统状态</div>
                <div class="debug-entry-content">
                    <p><strong>当前时间:</strong> ${new Date().toLocaleString()}</p>
                    <p><strong>对话数量:</strong> ${conversationsData.conversations?.length || 0}</p>
                    <p><strong>当前对话ID:</strong> ${currentConversationId || '无'}</p>
                    <p><strong>调试模式:</strong> 已开启</p>
                </div>
            </div>
            
            <div class="debug-entry ${messageSaveData.success ? 'success' : 'warning'}">
                <div class="debug-entry-header">💾 消息保存队列</div>
                <div class="debug-entry-content">
                    <p><strong>队列大小:</strong> ${messageSaveData.status?.queue_size || 0}</p>
                    <p><strong>工作线程:</strong> ${messageSaveData.status?.thread_status || '未知'}</p>
                    <p><strong>队列状态:</strong> ${messageSaveData.status?.queue_empty ? '空闲' : '工作中'}</p>
                    ${messageSaveData.status?.thread_id ? `<p><strong>线程ID:</strong> ${messageSaveData.status.thread_id}</p>` : ''}
                </div>
            </div>
            
            <div class="debug-entry ${langchainData.success ? 'success' : 'warning'}">
                <div class="debug-entry-header">🔗 LangChain配置</div>
                <div class="debug-json">${JSON.stringify(langchainData.config || {}, null, 2)}</div>
            </div>
        `;
    } catch (error) {
        debugSystem.innerHTML = `
            <div class="debug-entry error">
                <div class="debug-entry-header">加载失败</div>
                <div class="debug-entry-content">无法加载系统信息: ${error.message}</div>
            </div>
        `;
    }
}

// 加载数据库信息可视化
async function loadDatabaseInfo() {
    if (!debugMode || currentDebugTab !== 'database') return;
    
    const debugDatabase = document.getElementById('debugDatabase');
    if (!debugDatabase) {
        console.warn('[调试] debugDatabase元素不存在');
        return;
    }
    
    // 创建搜索界面
    debugDatabase.innerHTML = `
        <div class="database-search-panel">
            <div class="debug-entry info">
                <div class="debug-entry-header">🔍 数据库搜索</div>
                <div class="debug-entry-content">
                    <div class="search-controls" style="margin-bottom: 12px;">
                        <div class="input-group input-group-sm">
                            <input type="text" class="form-control" id="dbSearchInput" placeholder="输入对话ID或关键词搜索..." />
                            <select class="form-select" id="dbSearchType" style="max-width: 150px;">
                                <option value="keyword">关键词搜索</option>
                                <option value="conversation_id">对话ID</option>
                                <option value="all">全部</option>
                            </select>
                            <button class="btn btn-primary" type="button" id="dbSearchBtn">搜索</button>
                        </div>
                    </div>
                    <div class="search-quick-actions">
                        <button class="btn btn-outline-secondary btn-sm" onclick="quickSearchCurrentConv()">当前对话</button>
                        <button class="btn btn-outline-secondary btn-sm" onclick="quickSearchType('用户')">用户消息</button>
                        <button class="btn btn-outline-secondary btn-sm" onclick="quickSearchType('assistant')">AI回复</button>
                        <button class="btn btn-outline-secondary btn-sm" onclick="clearDatabaseSearch()">清空</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="databaseSearchResults"></div>
        <div id="databaseCurrentInfo"></div>
    `;
    
    // 绑定搜索事件
    document.getElementById('dbSearchBtn').addEventListener('click', performDatabaseSearch);
    document.getElementById('dbSearchInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            performDatabaseSearch();
        }
    });
    
    // 自动加载当前对话信息
    await loadCurrentDatabaseInfo();
}

// 执行数据库搜索
async function performDatabaseSearch() {
    const searchInput = document.getElementById('dbSearchInput');
    const searchType = document.getElementById('dbSearchType');
    const resultsDiv = document.getElementById('databaseSearchResults');
    
    const query = searchInput.value.trim();
    if (!query) {
        resultsDiv.innerHTML = `
            <div class="debug-entry warning">
                <div class="debug-entry-header">⚠️ 搜索提示</div>
                <div class="debug-entry-content">请输入搜索关键词</div>
            </div>
        `;
        return;
    }
    
    resultsDiv.innerHTML = '<div class="text-center py-3"><div class="spinner-border spinner-border-sm"></div> 搜索中...</div>';
    
    try {
        const response = await fetch(`/api/database_search?q=${encodeURIComponent(query)}&type=${searchType.value}`);
        const data = await response.json();
        
        if (!data.success) {
            throw new Error(data.error || '搜索失败');
        }
        
        renderSearchResults(data.results, query);
        
    } catch (error) {
        resultsDiv.innerHTML = `
            <div class="debug-entry error">
                <div class="debug-entry-header">❌ 搜索失败</div>
                <div class="debug-entry-content">${error.message}</div>
            </div>
        `;
    }
}

// 渲染搜索结果
function renderSearchResults(results, query) {
    const resultsDiv = document.getElementById('databaseSearchResults');
    
    if (results.conversations.length === 0 && results.messages.length === 0) {
        resultsDiv.innerHTML = `
            <div class="debug-entry warning">
                <div class="debug-entry-header">🔍 搜索结果</div>
                <div class="debug-entry-content">未找到匹配的结果</div>
            </div>
        `;
        return;
    }
    
    let html = `
        <div class="debug-entry success">
            <div class="debug-entry-header">🔍 搜索结果</div>
            <div class="debug-entry-content">
                <p><strong>搜索关键词:</strong> "${query}"</p>
                <p><strong>找到对话:</strong> ${results.search_stats.conversations_found} 个</p>
                <p><strong>找到消息组:</strong> ${results.search_stats.message_groups_found} 个</p>
                <p><strong>匹配消息数:</strong> ${results.search_stats.total_message_matches} 条</p>
                <p><strong>搜索时间:</strong> ${results.search_stats.search_time}</p>
            </div>
        </div>
    `;
    
    // 渲染对话结果
    if (results.conversations.length > 0) {
        html += `
            <div class="debug-entry">
                <div class="debug-entry-header">💬 匹配的对话 (${results.conversations.length})</div>
                <div class="debug-entry-content">
                    <div style="max-height: 300px; overflow-y: auto;">
        `;
        
        results.conversations.forEach(conv => {
            html += `
                <div class="conversation-result" style="margin-bottom: 12px; padding: 10px; border: 1px solid #e0e0e0; border-radius: 4px; cursor: pointer;" onclick="loadSpecificConversation('${conv.id}')">
                    <div style="font-weight: bold; color: #007bff;">${highlightText(conv.title, query)}</div>
                    <div style="font-size: 11px; color: #666;">
                        ID: <code>${conv.id}</code>
                        ${conv.match_type ? `| ${conv.match_type}` : ''}
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 4px;">
                        消息数: ${conv.message_count} | 创建: ${conv.created_at_formatted}
                        ${conv.matching_messages_count !== undefined ? `| 匹配消息: ${conv.matching_messages_count}` : ''}
                    </div>
                </div>
            `;
        });
        
        html += `
                    </div>
                </div>
            </div>
        `;
    }
    
    // 渲染消息结果
    if (results.messages.length > 0) {
        html += `
            <div class="debug-entry">
                <div class="debug-entry-header">📝 匹配的消息</div>
                <div class="debug-entry-content">
                    <div style="max-height: 400px; overflow-y: auto;">
        `;
        
        results.messages.forEach(group => {
            html += `
                <div class="message-group-result" style="margin-bottom: 15px; border-left: 3px solid #007bff; padding-left: 10px;">
                    <div style="font-weight: bold; margin-bottom: 8px;">
                        📁 ${group.conversation_title}
                        <span style="font-size: 11px; color: #666;">(${group.messages.length} 条匹配)</span>
                    </div>
            `;
            
            group.messages.forEach(msg => {
                const roleColor = msg.role === 'user' ? '#007bff' : '#28a745';
                const roleIcon = msg.role === 'user' ? '👤' : '🤖';
                
                html += `
                    <div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 4px;">
                        <div style="font-size: 11px; color: #666; margin-bottom: 4px;">
                            ${roleIcon} <span style="color: ${roleColor};">${msg.role.toUpperCase()}</span> 
                            | ${msg.created_at_formatted} 
                            | ${msg.content_length} 字符
                            | Token: ${msg.token_count || 0}
                        </div>
                        <div style="font-size: 12px; line-height: 1.4;">
                            ${highlightText(msg.content_preview, query)}
                        </div>
                    </div>
                `;
            });
            
            html += `</div>`;
        });
        
        html += `
                    </div>
                </div>
            </div>
        `;
    }
    
    resultsDiv.innerHTML = html;
}

// 高亮搜索关键词
function highlightText(text, query) {
    if (!query || !text) return text;
    
    const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
    return text.replace(regex, '<mark style="background-color: yellow; padding: 1px 2px;">$1</mark>');
}

// 快速搜索功能
function quickSearchCurrentConv() {
    if (currentConversationId) {
        document.getElementById('dbSearchInput').value = currentConversationId;
        document.getElementById('dbSearchType').value = 'conversation_id';
        performDatabaseSearch();
    }
}

function quickSearchType(type) {
    document.getElementById('dbSearchInput').value = type;
    document.getElementById('dbSearchType').value = 'keyword';
    performDatabaseSearch();
}

function clearDatabaseSearch() {
    document.getElementById('dbSearchInput').value = '';
    document.getElementById('databaseSearchResults').innerHTML = '';
}

// 加载指定对话的详细信息
async function loadSpecificConversation(conversationId) {
    const currentInfoDiv = document.getElementById('databaseCurrentInfo');
    currentInfoDiv.innerHTML = '<div class="text-center py-3"><div class="spinner-border spinner-border-sm"></div> 加载对话详情中...</div>';
    
    try {
        const response = await fetch(`/api/conversation_database_info/${conversationId}`);
        const data = await response.json();
        
        if (!data.success) {
            throw new Error(data.error || '获取对话信息失败');
        }
        
        renderConversationDetails(data);
        
    } catch (error) {
        currentInfoDiv.innerHTML = `
            <div class="debug-entry error">
                <div class="debug-entry-header">❌ 加载失败</div>
                <div class="debug-entry-content">${error.message}</div>
            </div>
        `;
    }
}

// 加载当前对话信息
async function loadCurrentDatabaseInfo() {
    if (!currentConversationId) {
        document.getElementById('databaseCurrentInfo').innerHTML = `
            <div class="debug-entry warning">
                <div class="debug-entry-header">⚠️ 无对话选中</div>
                <div class="debug-entry-content">请先选择一个对话来查看数据库信息，或使用上方搜索功能</div>
            </div>
        `;
        return;
    }
    
    await loadSpecificConversation(currentConversationId);
}

// 渲染对话详细信息
function renderConversationDetails(data) {
    const currentInfoDiv = document.getElementById('databaseCurrentInfo');
    const { conversation, messages, statistics, table_info, user_info, query_stats } = data;
        
    currentInfoDiv.innerHTML = `
            <!-- 消息列表 -->
            <div class="debug-entry">
                <div class="debug-entry-header">💬 消息列表 (${messages.length})</div>
                <div class="debug-entry-content">
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 4px; padding: 8px;">
                        ${messages.map(msg => `
                            <div style="margin-bottom: 10px; padding: 8px; border-radius: 4px; background: ${msg.role === 'user' ? 'rgba(0,123,255,0.1)' : 'rgba(40,167,69,0.1)'};">
                                <div style="font-size: 11px; color: #666; margin-bottom: 4px;">
                                    <strong>#${msg.sequence}</strong> | 
                                    <span style="color: ${msg.role === 'user' ? '#007bff' : '#28a745'};">${msg.role.toUpperCase()}</span> | 
                                    ${msg.created_at_formatted}
                                    ${msg.time_diff_formatted ? ` | ⏱️ ${msg.time_diff_formatted}` : ''}
                                </div>
                                <div style="font-size: 12px;">
                                    <strong>ID:</strong> <code style="font-size: 10px;">${msg.id}</code><br>
                                    <strong>长度:</strong> ${msg.content_length} 字符 | <strong>Token:</strong> ${msg.token_count || 0}<br>
                                    <strong>内容:</strong> ${msg.content_preview}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
            
            <!-- 对话统计 -->
            <div class="debug-entry success">
                <div class="debug-entry-header">📊 对话统计</div>
                <div class="debug-entry-content">
                    <p><strong>对话ID:</strong> <code>${conversation.id}</code></p>
                    <p><strong>标题:</strong> ${conversation.title}</p>
                    <p><strong>总消息数:</strong> ${statistics.total_messages} (用户: ${statistics.user_messages}, AI: ${statistics.ai_messages})</p>
                    <p><strong>总字符数:</strong> ${statistics.total_characters.toLocaleString()}</p>
                    <p><strong>总Token数:</strong> ${statistics.total_tokens.toLocaleString()}</p>
                    <p><strong>平均消息长度:</strong> ${statistics.avg_message_length} 字符</p>
                    ${statistics.conversation_duration_formatted ? `<p><strong>对话持续时间:</strong> ${statistics.conversation_duration_formatted}</p>` : ''}
                    <p><strong>创建时间:</strong> ${conversation.created_at_formatted}</p>
                </div>
            </div>
            
            <!-- 用户基本信息 -->
            <div class="debug-entry info">
                <div class="debug-entry-header">👤 用户信息</div>
                <div class="debug-entry-content">
                    <p><strong>用户名:</strong> ${user_info.username}</p>
                    <p><strong>邮箱:</strong> ${user_info.email}</p>
                    <p><strong>注册时间:</strong> ${user_info.created_at_formatted}</p>
                </div>
            </div>
            
            <!-- 用户统计 -->
            <div class="debug-entry">
                <div class="debug-entry-header">📈 用户统计</div>
                <div class="debug-entry-content">
                    <p><strong>用户对话数:</strong> ${query_stats.user_total_conversations}</p>
                    <p><strong>用户消息数:</strong> ${query_stats.user_total_messages}</p>
                    <p><strong>数据库总对话:</strong> ${query_stats.database_total_conversations}</p>
                    <p><strong>数据库总消息:</strong> ${query_stats.database_total_messages}</p>
                </div>
            </div>
        `;
}

// 页面加载时初始化
document.addEventListener('DOMContentLoaded', function() {
    const pageInitStart = performance.now();
    console.log(`🔍 [DEBUG] 页面初始化开始 - ${new Date().toLocaleTimeString()}`);
    
    // 初始化Markdown解析器
    const markdownStart = performance.now();
    if (typeof marked !== 'undefined') {
        marked.setOptions({
            breaks: true,
            gfm: true,
            sanitize: false,
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (err) {}
                }
                return hljs.highlightAuto(code).value;
            }
        });
        console.log(`✅ [DEBUG] Markdown解析器初始化完成: ${(performance.now() - markdownStart).toFixed(3)}ms`);
    } else {
        console.warn(`⚠️ [DEBUG] Markdown解析器未就绪`);
    }
    
    const setupStart = performance.now();
    setupEventListeners();
    console.log(`✅ [DEBUG] 事件监听器设置完成: ${(performance.now() - setupStart).toFixed(3)}ms`);
    
    // 🔥 修复：初始化按钮状态
    const buttonStart = performance.now();
    updateSendButtonState();
    console.log(`✅ [DEBUG] 按钮状态初始化完成: ${(performance.now() - buttonStart).toFixed(3)}ms`);
    
    // 初始化调试功能
    const debugStart = performance.now();
    initializeDebugFeatures();
    console.log(`✅ [DEBUG] 调试功能初始化完成: ${(performance.now() - debugStart).toFixed(3)}ms`);
    
    // V0.3.0 初始化配置功能
    const configStart = performance.now();
    initializeConfigFeatures();
    console.log(`✅ [DEBUG] 配置功能初始化完成: ${(performance.now() - configStart).toFixed(3)}ms`);
    
    // V0.3.1 修复：移除自动测试功能，避免调试面板自动弹出
    // 测试函数仍可通过控制台手动调用：testConfig(), testDebugFeatures(), testConfigModalSafety()
    console.log('[DEBUG] 测试函数可通过控制台手动调用: testConfig(), testDebugFeatures(), testConfigModalSafety(), testConfigSave(), testAutoSave(), fixTemperatureSelect()');
    
    // 在聊天页面禁用全局侧边栏功能
    const sidebarStart = performance.now();
    disableGlobalSidebar();
    console.log(`✅ [DEBUG] 全局侧边栏禁用完成: ${(performance.now() - sidebarStart).toFixed(3)}ms`);
    
    // 异步加载数据
    loadConversationsAndInitialize().then(() => {
        const totalTime = performance.now() - pageInitStart;
        console.log(`🎉 [DEBUG] 页面完全初始化完成: ${totalTime.toFixed(3)}ms`);
    }).catch(error => {
        const totalTime = performance.now() - pageInitStart;
        console.error(`❌ [DEBUG] 页面初始化失败: ${error.message} (耗时: ${totalTime.toFixed(3)}ms)`);
    });
});

// 设置事件监听器
function setupEventListeners() {
    const messageInput = document.getElementById('messageInput');
    const chatForm = document.getElementById('chatForm');
    const newChatBtn = document.getElementById('newChatBtn');
    const sendBtn = document.getElementById('sendBtn');
    const toggleSidebar = document.getElementById('toggleSidebar');
    const showSidebar = document.getElementById('showSidebar');
    const conversationSearch = document.getElementById('conversationSearch');
    const sidebarOverlay = document.getElementById('sidebarOverlay'); // 使用base.html中的遮罩层
    const sidebarTriggerChat = document.getElementById('sidebarTriggerChat');
    
    // 自动调整文本框高度并更新按钮状态
    messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        updateSendButtonState();
    });
    
    // 输入框聚焦时更新按钮状态
    messageInput.addEventListener('focus', function() {
        updateSendButtonState();
    });
    
    // 键盘快捷键
    messageInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            if (!isLoading && this.value.trim()) {
                chatForm.dispatchEvent(new Event('submit'));
            }
        }
    });
    
    // 表单提交
    chatForm.addEventListener('submit', handleSendMessage);
    
    // 新对话按钮
    newChatBtn.addEventListener('click', startNewConversation);
    
    // 侧边栏控制
    toggleSidebar.addEventListener('click', hideSidebar);
    showSidebar.addEventListener('click', showSidebarPanel);
    if (sidebarTriggerChat) {
        sidebarTriggerChat.addEventListener('click', showSidebarPanel);
    }
    if (sidebarOverlay) {
        sidebarOverlay.addEventListener('click', hideSidebar); // 点击遮罩层关闭侧边栏
    }
    
    // 对话搜索
    conversationSearch.addEventListener('input', filterConversations);
    
    // 分享对话模态框事件监听
    setupShareConversationModal();
}

// 设置分享对话模态框事件监听
function setupShareConversationModal() {
    const modal = document.getElementById('shareConversationModal');
    const descriptionTextarea = document.getElementById('shareConversationDescription');
    
    // 点击背景关闭模态框
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            closeShareConversationModal();
        }
    });
    
    // ESC键关闭模态框
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && modal.style.display === 'block') {
            closeShareConversationModal();
        }
    });
    
    // 描述输入框字符计数器
    descriptionTextarea.addEventListener('input', updateCharCounter);
}

// 禁用全局侧边栏功能
function disableGlobalSidebar() {
    // 隐藏全局侧边栏
    const globalSidebar = document.getElementById('sidebar');
    if (globalSidebar) {
        globalSidebar.style.display = 'none';
    }
    
    // 移除全局侧边栏触发器的事件监听
    const globalTrigger = document.getElementById('sidebarTrigger');
    if (globalTrigger) {
        globalTrigger.style.display = 'none';
        // 移除所有事件监听器
        globalTrigger.replaceWith(globalTrigger.cloneNode(true));
    }
    
    // 移除全局侧边栏的鼠标事件
    const globalSidebarOverlay = document.getElementById('sidebarOverlay');
    if (globalSidebarOverlay) {
        // 只在聊天页面使用遮罩层，不让全局侧边栏使用
        globalSidebarOverlay.removeAttribute('onclick');
    }
    
    // 隐藏顶部导航栏的侧边栏按钮
    const sidebarToggle = document.getElementById('sidebarToggle');
    if (sidebarToggle) {
        sidebarToggle.style.display = 'none';
    }
    
    console.log('全局侧边栏功能已在聊天页面禁用');
}

// 加载对话列表并初始化页面
async function loadConversationsAndInitialize() {
    const startTime = performance.now();
    console.log(`🔍 [DEBUG] 开始加载对话列表并初始化 - ${new Date().toLocaleTimeString()}`);
    
    try {
        // 🔥 新增：检查是否有要导入的对话
        const urlParams = new URLSearchParams(window.location.search);
        const shouldImport = urlParams.get('import') === 'true';
        
        if (shouldImport) {
            const importedData = sessionStorage.getItem('importedConversation');
            if (importedData) {
                try {
                    const conversationData = JSON.parse(importedData);
                    sessionStorage.removeItem('importedConversation'); // 清理数据
                    
                    // 开始新对话并导入消息
                    startNewConversation();
                    
                    // 设置对话标题
                    if (conversationData.title) {
                        document.getElementById('conversationTitle').textContent = conversationData.title;
                    }
                    
                    // 导入消息
                    if (conversationData.messages && conversationData.messages.length > 0) {
                        for (const message of conversationData.messages) {
                            addMessage(message.role, message.content);
                        }
                        
                        // 显示导入成功提示
                        showToast('对话已成功导入！您可以继续与AI对话。', 'success');
                    }
                    
                    // 清理URL参数
                    window.history.replaceState({}, document.title, window.location.pathname);
                    return;
                } catch (error) {
                    console.error('导入对话数据解析失败:', error);
                    showToast('导入对话失败：数据格式错误', 'error');
                }
            }
        }
        
        // 正常加载对话列表
        const fetchStart = performance.now();
        const response = await fetch('/api/conversations');
        const fetchEnd = performance.now();
        
        const parseStart = performance.now();
        const data = await response.json();
        const parseEnd = performance.now();
        
        if (data.success) {
            const renderStart = performance.now();
            conversations = data.conversations;
            renderConversationList(conversations);
            const renderEnd = performance.now();
            
            // 如果有对话历史，自动加载最近的对话
            if (conversations.length > 0) {
                const loadStart = performance.now();
                const latestConversation = conversations[0]; // 已按更新时间倒序排列
                await switchConversation(latestConversation.id);
                const loadEnd = performance.now();
                
                const totalTime = loadEnd - startTime;
                console.log(`✅ [DEBUG] 对话列表加载完成并切换到最新对话:`);
                console.log(`   - 网络请求: ${(fetchEnd - fetchStart).toFixed(3)}ms`);
                console.log(`   - 数据解析: ${(parseEnd - parseStart).toFixed(3)}ms`);
                console.log(`   - 列表渲染: ${(renderEnd - renderStart).toFixed(3)}ms`);
                console.log(`   - 对话切换: ${(loadEnd - loadStart).toFixed(3)}ms`);
                console.log(`   - 总耗时: ${totalTime.toFixed(3)}ms`);
                console.log(`   - 对话数量: ${conversations.length}`);
            } else {
                // 没有历史对话，显示新对话页面
                startNewConversation();
                const totalTime = performance.now() - startTime;
                console.log(`✅ [DEBUG] 对话列表加载完成(无历史对话): ${totalTime.toFixed(3)}ms`);
            }
        } else {
            const errorTime = performance.now() - startTime;
            console.error(`❌ [DEBUG] 加载对话列表失败: ${data.message} (耗时: ${errorTime.toFixed(3)}ms)`);
            startNewConversation();
        }
    } catch (error) {
        const errorTime = performance.now() - startTime;
        console.error(`❌ [DEBUG] 加载对话列表异常: ${error.message} (耗时: ${errorTime.toFixed(3)}ms)`);
        startNewConversation();
    }
}

// 加载对话列表（不初始化页面）
async function loadConversations() {
    try {
        // 添加时间戳参数避免缓存
        const response = await fetch(`/api/conversations?t=${Date.now()}`);
        const data = await response.json();
        
        if (data.success) {
            conversations = data.conversations;
            renderConversationList(conversations);
        } else {
            console.error('加载对话列表失败:', data.message);
        }
    } catch (error) {
        console.error('加载对话列表异常:', error);
    }
}

// 渲染对话列表
function renderConversationList(conversationList) {
    const conversationListEl = document.getElementById('conversationList');
    
    if (conversationList.length === 0) {
        conversationListEl.innerHTML = `
            <div class="empty-conversations text-center py-4">
                <i class="bi bi-chat-text text-muted" style="font-size: 2rem;"></i>
                <p class="text-muted mt-2">还没有对话历史</p>
                <small class="text-muted">点击上方"新建对话"开始</small>
            </div>
        `;
        return;
    }
    
    const conversationItems = conversationList.map(conv => {
        const isActive = conv.id === currentConversationId;
        
        // 安全的日期处理
        let lastUpdate = '未知时间';
        try {
            if (conv.last_message_time) {
                const date = new Date(conv.last_message_time);
                if (!isNaN(date.getTime())) {
                    const now = new Date();
                    const diffMs = now - date;
                    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                    const diffDays = Math.floor(diffHours / 24);
                    
                    if (diffDays > 0) {
                        lastUpdate = `${diffDays}天前`;
                    } else if (diffHours > 0) {
                        lastUpdate = `${diffHours}小时前`;
                    } else {
                        const diffMinutes = Math.floor(diffMs / (1000 * 60));
                        lastUpdate = diffMinutes > 0 ? `${diffMinutes}分钟前` : '刚刚';
                    }
                }
            } else if (conv.updated_at) {
                const date = new Date(conv.updated_at);
                if (!isNaN(date.getTime())) {
                    lastUpdate = date.toLocaleDateString();
                }
            }
        } catch (error) {
            console.warn('日期解析失败:', conv.updated_at, error);
        }
        
        // 消息预览
        const messagePreview = conv.last_message_preview || '暂无消息';
        
        return `
            <div class="conversation-item ${isActive ? 'active' : ''}" 
                 data-conversation-id="${conv.id}"
                 onclick="switchConversation('${conv.id}')">
                <div class="conversation-content">
                    <div class="conversation-title">${conv.title}</div>
                    <div class="conversation-preview">
                        <small class="text-muted">${messagePreview}</small>
                    </div>
                    <div class="conversation-meta">
                        <small class="text-muted">
                            <i class="bi bi-chat-dots"></i> ${conv.message_count} 条消息
                        </small>
                        <small class="text-muted">
                            <i class="bi bi-clock"></i> ${lastUpdate}
                        </small>
                    </div>
                </div>
                <div class="conversation-actions">
                    <button class="btn btn-sm btn-outline-primary me-2" onclick="shareConversation('${conv.id}', event)" title="分享到论坛">
                        <i class="bi bi-share"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-danger" onclick="deleteConversation('${conv.id}', event)" title="删除对话">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
            </div>
        `;
    }).join('');
    
    conversationListEl.innerHTML = conversationItems;
}

// 切换对话
async function switchConversation(conversationId) {
    if (conversationId === currentConversationId) {
        console.log('切换到相同对话，跳过');
        return;
    }
    
    console.log(`[UI] 切换对话: ${conversationId}`);
    currentConversationId = conversationId;
    
    // 更新UI状态
    updateActiveConversation(conversationId);
    
    // 加载对话历史
    await loadConversationHistory(conversationId);
    
    // V0.3.1 修复：加载对话配置并显示模型参数
    try {
        console.log('[配置] 切换对话，加载配置 ID:', conversationId);
        const configResponse = await fetch(`/api/conversations/${conversationId}/config`);
        const configData = await configResponse.json();
        
        if (configData.success) {
            currentConfig = configData.config;
            console.log('[配置] 切换对话后更新currentConfig:', currentConfig);
            
            // 如果调试模式开启，立即显示模型参数
            if (debugMode) {
                updateModelParamsDebug({
                    model_name: currentConfig.model_name,
                    temperature: currentConfig.temperature,
                    max_tokens: currentConfig.max_tokens,
                    has_system_prompt: !!currentConfig.system_prompt,
                    system_prompt_length: currentConfig.system_prompt ? currentConfig.system_prompt.length : 0
                });
            }
        } else {
            console.warn('[配置] 获取对话配置失败:', configData.message);
            // 使用默认配置
            ensureDefaultConfig();
        }
    } catch (error) {
        console.error('[配置] 加载对话配置失败:', error);
        // 使用默认配置
        ensureDefaultConfig();
    }
    
    // 如果调试模式开启且当前在数据库标签，刷新数据库信息
    if (debugMode && currentDebugTab === 'database') {
        await loadDatabaseInfo();
    }
}

// 更新活跃对话状态
function updateActiveConversation(conversationId) {
    // 更新对话列表中的活跃状态
    document.querySelectorAll('.conversation-item').forEach(item => {
        item.classList.remove('active');
        if (item.dataset.conversationId === conversationId) {
            item.classList.add('active');
        }
    });
    
    // 更新标题（保留编辑图标）
    const conversation = conversations.find(c => c.id === conversationId);
    if (conversation) {
        const titleElement = document.getElementById('currentChatTitle');
        titleElement.innerHTML = `${conversation.title}<i class="bi bi-pencil-square edit-icon"></i>`;
    }
}

// 加载对话历史
async function loadConversationHistory(conversationId) {
    try {
        // 添加时间戳参数避免缓存
        const response = await fetch(`/api/conversations/${conversationId}/messages?t=${Date.now()}`);
        const data = await response.json();
        
        if (data.success) {
            console.log(`[数据库] 加载对话历史: ${data.messages ? data.messages.length : 0} 条消息`);
            
            // 清空当前聊天区域
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';
            console.log('聊天区域已清空');
            
            // 渲染历史消息
            if (data.messages && data.messages.length > 0) {
                // console.log('开始渲染历史消息...');
                
                // 测试addMessage函数是否存在
                if (typeof addMessage !== 'function') {
                    console.error('addMessage 函数不存在!');
                    return;
                }
                
                data.messages.forEach((msg, index) => {
                    // console.log(`渲染历史消息 ${index + 1}:`, {
                    //     role: msg.role,
                    //     content: msg.content.substring(0, 100) + '...',
                    //     contentLength: msg.content.length
                    // });
                    
                    try {
                        // V0.3.1 修复：传递思考过程给addMessage
                        addMessage(msg.role, msg.content, false, msg.thinking_process);
                        // console.log(`消息 ${index + 1} 渲染完成`);
                    } catch (error) {
                        console.error(`渲染消息 ${index + 1} 失败:`, error);
                    }
                });
                console.log(`[UI] 已渲染 ${data.messages.length} 条历史消息`);
                
                // 检查渲染后的DOM
                const messagesAfter = chatMessages.children.length;
                // console.log('渲染后聊天区域的子元素数量:', messagesAfter);
            } else {
                console.log('该对话暂无历史消息');
            }
            
            // 隐藏欢迎消息
            const welcomeMessage = document.getElementById('welcomeMessage');
            if (welcomeMessage) {
                welcomeMessage.style.display = 'none';
            }
            
            // 滚动到底部
            setTimeout(() => {
                scrollToBottom();
            }, 100);
        } else {
            console.error('加载对话历史失败:', data.message);
        }
    } catch (error) {
        console.error('加载对话历史异常:', error);
    }
}

// 开始新对话 - V0.3.0 新建时弹出参数确认
function startNewConversation() {
    console.log('[配置] 开始新对话');
    
    // V0.3.1 修复：确保默认配置正确初始化
    ensureDefaultConfig();
    
    // 设置模态框为新建模式
    configModalMode = 'create';
    document.getElementById('configModalTitle').textContent = '新建对话 - 参数设置';
    document.getElementById('saveConfigBtnText').textContent = '开始对话';
    
    // 重置为默认配置
    currentConfig = {
        model_name: 'deepseek-chat',
        temperature: 1.0,
        max_tokens: 4000,
        system_prompt: ''
    };
    
    console.log('[配置] 重置为默认配置:', currentConfig);
    
    // 填充默认配置到表单
    fillConfigForm(currentConfig);
    updateConfigPreview();
    
    // 显示配置模态框
    const modal = new bootstrap.Modal(document.getElementById('configModal'));
    modal.show();
}

// 实际开始新对话（配置确认后）
function doStartNewConversation() {
    currentConversationId = null;
    
    // 清空聊天区域
    const chatMessages = document.getElementById('chatMessages');
    chatMessages.innerHTML = `
        <div class="welcome-message" id="welcomeMessage">
            <i class="bi bi-chat-dots welcome-icon"></i>
            <h4>开始新的对话</h4>
            <p class="text-muted small">
                模型: ${currentConfig.model_name === 'deepseek-chat' ? 'DeepSeek-V3' : 'DeepSeek-R1'} | 
                温度: ${currentConfig.temperature} | 
                输出: ${currentConfig.max_tokens}Token
            </p>
        </div>
    `;
    
    // 更新标题（保留编辑图标）
    document.getElementById('currentChatTitle').innerHTML = '智能问答<i class="bi bi-pencil-square edit-icon"></i>';
    
    // 清除活跃状态
    document.querySelectorAll('.conversation-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // 聚焦输入框
    document.getElementById('messageInput').focus();
}

// 删除对话
async function deleteConversation(conversationId, event) {
    event.stopPropagation();
    
    if (!confirm('确定要删除这个对话吗？此操作不可撤销。')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/conversations/${conversationId}`, {
            method: 'DELETE'
        });
        
        const data = await response.json();
        
        if (data.success) {
            // 如果删除的是当前对话，开始新对话
            if (conversationId === currentConversationId) {
                startNewConversation();
            }
            
            // 重新加载对话列表
            await loadConversations();
        } else {
            alert('删除对话失败: ' + data.message);
        }
    } catch (error) {
        console.error('删除对话异常:', error);
        alert('删除对话失败，请稍后重试');
    }
}

// 过滤对话
function filterConversations() {
    const searchTerm = document.getElementById('conversationSearch').value.toLowerCase();
    const filteredConversations = conversations.filter(conv => 
        conv.title.toLowerCase().includes(searchTerm)
    );
    renderConversationList(filteredConversations);
}

// 显示/隐藏侧边栏
function showSidebarPanel() {
    const sidebar = document.getElementById('chatSidebar');
    const overlay = document.getElementById('sidebarOverlay');
    const chatContainer = document.getElementById('chatContainer');
    
    sidebar.classList.remove('hidden');
    sidebar.classList.add('show');
    chatContainer.classList.remove('sidebar-hidden');
    
    // 移动端显示遮罩层
    if (window.innerWidth <= 768 && overlay) {
        overlay.classList.add('show');
    }
}

function hideSidebar() {
    const sidebar = document.getElementById('chatSidebar');
    const overlay = document.getElementById('sidebarOverlay');
    const chatContainer = document.getElementById('chatContainer');
    
    sidebar.classList.remove('show');
    sidebar.classList.add('hidden');
    chatContainer.classList.add('sidebar-hidden');
    
    if (overlay) {
        overlay.classList.remove('show');
    }
}

// 处理发送消息
async function handleSendMessage(event) {
    event.preventDefault();
    
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const message = messageInput.value.trim();
    
    if (!message || isLoading) return;
    
    // 添加调试信息
    addDebugEntry('user', `发送消息: ${message.substring(0, 100)}${message.length > 100 ? '...' : ''}`, 'info');
    
    try {
        // 保存发送前的状态
        const previousState = {
            message: message,
            conversationId: currentConversationId
        };
        
        // 设置加载状态
        isLoading = true;
        window.lastSendTime = Date.now(); // 记录发送时间，用于超时检测
        // 🔥 修复：使用统一的状态管理函数
        updateSendButtonState();
        
        // 添加用户消息到界面
        addMessage('user', message);
        messageInput.value = '';
        messageInput.style.height = 'auto';
        
        addDebugEntry('system', '用户消息已添加到界面', 'info');
        
        // 设置恢复超时
        const recoveryTimeout = setTimeout(() => {
            if (isLoading) {
                console.warn('[错误恢复] 检测到请求可能超时，尝试恢复状态');
                addDebugEntry('error', '请求超时（30秒），尝试恢复状态', 'error');
                recoverFromError(previousState);
            }
        }, 30000); // 30秒超时
        
        try {
            // 使用流式响应
            const url = new URL('/api/chat', window.location.origin);
            url.searchParams.set('stream', 'true');
            
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message: message,
                    conversation_id: currentConversationId,
                    // V0.3.0 新增：发送配置信息
                    conversation_config: currentConversationId ? null : currentConfig
                    // V0.3.0 移除 knowledge_base_id 参数
                })
            });
            
            // 清除恢复超时
            clearTimeout(recoveryTimeout);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
                    // 创建AI消息容器
        const assistantMessageDiv = createMessageContainer('assistant');
        const messageContent = assistantMessageDiv.querySelector('.message-content');
        let aiResponse = '';
        
        // 🔥 新增：显示等待动画
        messageContent.innerHTML = `
            <div class="waiting-animation">
                <span class="waiting-text">正在思考</span>
                <span class="waiting-dots">
                    <span>.</span><span>.</span><span>.</span>
                </span>
            </div>
        `;
        
        // 🔥 新增：隐藏渲染按钮直到输出完成
        const toggleBtn = assistantMessageDiv.querySelector('.message-toggle-btn');
        if (toggleBtn) {
            toggleBtn.style.display = 'none';
        }
            
            // 处理流式响应
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                
                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.slice(6));
                            
                            switch (data.type) {
                                case 'start':
                                    addDebugEntry('stream', '开始接收AI响应', 'info');
                                    currentConversationId = data.conversation_id;
                                    
                                    // 保存调试信息
                                    if (data.debug_info) {
                                        addDebugEntry('debug', '收到调试信息', 'info', data.debug_info);
                                    }
                                    
                                    // 更新对话标题（如果是新对话）
                                    if (!conversations.find(c => c.id === currentConversationId)) {
                                        const title = message.length > 30 ? message.substring(0, 30) + '...' : message;
                                        document.getElementById('currentChatTitle').textContent = title;
                                        
                                        // 立即添加新对话到列表顶部
                                        const newConversation = {
                                            id: currentConversationId,
                                            title: title,
                                            created_at: new Date().toISOString(),
                                            message_count: 1
                                        };
                                        conversations.unshift(newConversation);
                                        renderConversationList(conversations);
                                        
                                        // 设置为活跃状态
                                        setTimeout(() => {
                                            const newItem = document.querySelector(`[data-conversation-id="${currentConversationId}"]`);
                                            if (newItem) {
                                                document.querySelectorAll('.conversation-item').forEach(item => {
                                                    item.classList.remove('active');
                                                });
                                                newItem.classList.add('active');
                                            }
                                        }, 100);
                                    }
                                    break;
                                case 'processing':
                                    // 🔥 修复BUG2：处理处理状态消息，给用户即时反馈
                                    console.log('[模型] 处理状态:', data.status);
                                    addDebugEntry('stream', `处理状态: ${data.status}`, 'info');
                                    
                                    // V0.3.0 显示模型参数
                                    if (data.model_params) {
                                        updateModelParamsDebug(data.model_params);
                                    }
                                    break;
                                case 'content':
                                    aiResponse += data.content;
                                    
                                    // 🔥 新增：第一次收到内容时清除等待动画
                                    if (aiResponse === data.content && messageContent.querySelector('.waiting-animation')) {
                                        messageContent.innerHTML = '';
                                    }
                                    
                                    // 更新原文内容
                                    const messageRaw = assistantMessageDiv.querySelector('.message-raw');
                                    if (messageRaw) {
                                        messageRaw.textContent = aiResponse;
                                    }
                                    // 渲染Markdown
                                    messageContent.innerHTML = renderMarkdown(aiResponse);
                                    // 代码高亮和复制按钮
                                    messageContent.querySelectorAll('pre code').forEach((block) => {
                                        hljs.highlightElement(block);
                                        addCopyButtonToCodeBlock(block.parentElement);
                                    });
                                    // 渲染数学公式
                                    renderMath(messageContent);
                                    scrollToBottom();
                                    break;
                                case 'thinking_stream':
                                    // V0.3.1 修复：DeepSeek R1 流式思考过程显示
                                    if (data.content) {
                                        // 自动启用思考过程显示（R1模型）
                                        const isR1Model = currentConfig.model_name === 'deepseek-reasoner';
                                        const enableThinkingCheckbox = document.getElementById('enableThinking');
                                        
                                        if (isR1Model && enableThinkingCheckbox && !enableThinkingCheckbox.checked) {
                                            console.log('[R1] 自动启用思考过程显示');
                                            enableThinkingCheckbox.checked = true;
                                        }
                                        
                                        // 显示思考过程（R1模型或用户手动启用时）
                                        if (isR1Model || (enableThinkingCheckbox && enableThinkingCheckbox.checked)) {
                                            // 流式添加思考内容
                                            addThinkingStreamToMessage(assistantMessageDiv, data.content);
                                            scrollToBottom();
                                        }
                                    }
                                    break;
                                case 'thinking_complete':
                                    // V0.3.1 修复：思考过程完成，自动折叠并准备正文显示
                                    if (data.thinking_process) {
                                        const isR1Model = currentConfig.model_name === 'deepseek-reasoner';
                                        const enableThinkingCheckbox = document.getElementById('enableThinking');
                                        
                                        if (isR1Model || (enableThinkingCheckbox && enableThinkingCheckbox.checked)) {
                                            // 完成思考过程显示并自动折叠
                                            completeThinkingProcessInMessage(assistantMessageDiv, data.thinking_process);
                                            console.log('[R1] 思考过程完成，已自动折叠');
                                            addDebugEntry('stream', 'DeepSeek-R1思考过程完成并折叠', 'success');
                                            scrollToBottom();
                                        }
                                    }
                                    break;
                                case 'done':
                                    console.log('[模型] 流式响应完成');
                                    addDebugEntry('stream', '流式响应完成', 'success');
                                    
                                    // V0.3.1 修复：DeepSeek R1 思考过程显示（done事件兼容处理）
                                    if (data.thinking_process && data.has_thinking) {
                                        const isR1Model = currentConfig.model_name === 'deepseek-reasoner';
                                        const enableThinkingCheckbox = document.getElementById('enableThinking');
                                        
                                        // 显示思考过程（R1模型或用户手动启用时）
                                        if (isR1Model || (enableThinkingCheckbox && enableThinkingCheckbox.checked)) {
                                            // 检查是否已经有思考过程显示（新流式模式处理过的）
                                            const existingThinking = assistantMessageDiv.querySelector('.thinking-process-container');
                                            if (!existingThinking) {
                                                // 兼容旧模式：直接添加思考过程（折叠状态）
                                                addThinkingProcessToMessage(assistantMessageDiv, data.thinking_process);
                                                console.log('[R1] done事件兼容模式添加思考过程显示');
                                            } else {
                                                console.log('[R1] done事件检测到已有思考过程，跳过重复添加');
                                            }
                                        } else {
                                            console.log('[R1] done事件思考过程已收到但未显示（用户未启用）');
                                        }
                                    }
                                    
                                    try {
                                        // 更新调试信息
                                        if (data.debug_info) {
                                            addDebugEntry('debug', '收到完整调试信息', 'success', data.debug_info);
                                            
                                            // 🔥 显示数据库操作信息
                                            if (data.debug_info.db_operations && data.debug_info.db_operations.length > 0) {
                                                updateDatabaseDebug(data.debug_info.db_operations);
                                            }
                                            
                                            // V0.3.1 更新API交互调试信息
                                            const apiInteraction = {
                                                user_message: data.debug_info.user_message || '未知',
                                                request: data.debug_info.api_request || {},
                                                response: data.debug_info.api_response || {},
                                                response_success: true,
                                                response_content: data.full_response || aiResponse,
                                                thinking_process: data.thinking_process || null,
                                                processing_time: data.debug_info.timing?.total_time,
                                                token_usage: data.debug_info.api_response?.usage || '未知'
                                            };
                                            updateContextDebug(apiInteraction);
                                            
                                            if (data.debug_info.langchain_enabled) {
                                                updateLangChainDebug({
                                                    enabled: true,
                                                    memory_type: data.debug_info.langchain_result?.context_info?.memory_type,
                                                    processing_time: data.debug_info.timing?.total_time,
                                                    context_info: data.debug_info.context_info,
                                                    processing_steps: data.debug_info.processing_steps
                                                });
                                            } else {
                                                updateLangChainDebug({
                                                    enabled: false
                                                });
                                            }
                                            
                                            // 显示消息保存状态
                                            if (data.debug_info.final_stats) {
                                                const stats = data.debug_info.final_stats;
                                                addDebugEntry('database', 
                                                    `消息保存状态: ${stats.save_queued ? '已加入队列' : '未保存'}, 队列大小: ${stats.queue_size || 0}`, 
                                                    stats.save_queued ? 'success' : 'warning'
                                                );
                                            }
                                        }
                                        
                                        // 流式响应已完成，AI消息已在服务器端保存
                                        console.log(`[数据库] AI消息已保存: ${data.message_id}`);
                                        
                                        // 刷新对话列表以显示更新
                                        await loadConversations();
                                        console.log('[UI] 对话列表已刷新');
                                        
                                        // 重置所有状态
                                        isLoading = false;
                                        window.lastSendTime = null; // 清除发送时间记录
                                        
                                        // 🔥 修复：使用统一的状态管理函数  
                                        updateSendButtonState();
                                        
                                        // 🔥 新增：显示渲染按钮
                                        const toggleBtn = assistantMessageDiv.querySelector('.message-toggle-btn');
                                        if (toggleBtn) {
                                            toggleBtn.style.display = 'inline-block';
                                        }
                                        
                                        // 自动聚焦到输入框
                                        const messageInput = document.getElementById('messageInput');
                                        if (messageInput) {
                                            messageInput.focus();
                                        }
                                        
                                        addDebugEntry('system', '消息处理完成，状态已重置', 'success');
                                        
                                    } catch (error) {
                                        console.error('done事件处理异常:', error);
                                        addDebugEntry('error', `done事件处理异常: ${error.message}`, 'error');
                                    }
                                    break;
                                case 'error':
                                    console.error('AI响应错误:', data.error);
                                    try {
                                        const errorMessage = `抱歉，出现了错误：${data.error}`;
                                        messageContent.innerHTML = renderMarkdown(errorMessage);
                                        assistantMessageDiv.querySelector('.message-bubble').classList.add('error');
                                        // 更新原文内容
                                        const errorMessageRaw = assistantMessageDiv.querySelector('.message-raw');
                                        if (errorMessageRaw) {
                                            errorMessageRaw.textContent = errorMessage;
                                        }
                                        // 渲染数学公式
                                        renderMath(messageContent);
                                    } catch (error) {
                                        console.error('error事件处理异常:', error);
                                    } finally {
                                        // 重置加载状态
                                        isLoading = false;
                                        window.lastSendTime = null; // 清除发送时间记录
                                        
                                        // 🔥 修复：使用统一的状态管理函数
                                        updateSendButtonState();
                                        
                                        // 🔥 新增：错误时也要显示渲染按钮
                                        const toggleBtn = assistantMessageDiv.querySelector('.message-toggle-btn');
                                        if (toggleBtn) {
                                            toggleBtn.style.display = 'inline-block';
                                        }
                                        
                                        console.log('error事件处理完成，按钮状态已恢复，isLoading=', isLoading);
                                    }
                                    break;
                            }
                        } catch (e) {
                            console.error('解析SSE数据失败:', e);
                        }
                    }
                }
            }
            
        } catch (error) {
            console.error('发送消息失败:', error);
            recoverFromError(previousState);
            addMessage('assistant', '抱歉，发送消息时出现错误，请重试。', true);
        }
    } catch (error) {
        console.error('处理消息失败:', error);
        addMessage('assistant', '抱歉，处理消息时出现错误，请重试。', true);
    }
}

// 添加错误恢复函数
function recoverFromError(previousState) {
    console.log('[错误恢复] 开始恢复状态');
    
    // 重置加载状态
    isLoading = false;
    window.lastSendTime = null; // 清除发送时间记录
    
    // 恢复UI元素
    const messageInput = document.getElementById('messageInput');
    
    // 🔥 修复：恢复输入框内容并聚焦
    if (messageInput) {
        messageInput.value = previousState.message;
        messageInput.focus();
    }
    
    // 🔥 修复：使用统一的状态管理函数
    updateSendButtonState();
    
    // 恢复对话ID
    if (previousState.conversationId) {
        currentConversationId = previousState.conversationId;
    }
    
    console.log('[错误恢复] 状态已恢复');
}

// 创建消息容器（用于流式响应）
function createMessageContainer(role, isError = false) {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${role}`;
    
    const bubbleClass = isError ? 'message-bubble error' : 'message-bubble';
    
    // 根据角色决定头像和消息的顺序
    if (role === 'user') {
        // 用户消息：头像在右侧！ HTML结构要明确：气泡 + 头像
        messageDiv.innerHTML = `
            <div class="${bubbleClass}">
                <div class="message-content"></div>
            </div>
            <div class="message-avatar">
                <i class="bi bi-person-fill"></i>
            </div>
        `;
    } else {
        // AI消息：头像在左，消息气泡在右，包含切换按钮
        const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        messageDiv.innerHTML = `
            <div class="message-avatar">
                <i class="bi bi-robot"></i>
            </div>
            <div class="${bubbleClass}">
                <div class="message-header">
                    <button class="btn btn-outline-secondary btn-sm message-toggle-btn" 
                            onclick="toggleMessageFormat('${messageId}')" 
                            title="切换原文/渲染视图">
                        <i class="bi bi-eye"></i> 渲染
                    </button>
                </div>
                <div class="message-content" id="${messageId}"></div>
                <div class="message-raw" id="${messageId}_raw" style="display: none;"></div>
            </div>
        `;
    }
    
    chatMessages.appendChild(messageDiv);
    scrollToBottom();
    return messageDiv;
}

// 添加消息到聊天区域 - V0.3.1 支持思考过程
function addMessage(role, content, isError = false, thinkingProcess = null) {
    // console.log(`添加消息: role=${role}, contentLength=${content.length}, isError=${isError}`);
    
    // 🔥 修复BUG1：添加消息时立即隐藏欢迎消息
    const welcomeMessage = document.getElementById('welcomeMessage');
    if (welcomeMessage && welcomeMessage.style.display !== 'none') {
        welcomeMessage.style.display = 'none';
    }
    
    const messageDiv = createMessageContainer(role, isError);
    const messageContent = messageDiv.querySelector('.message-content');
    
    if (!messageContent) {
        console.error('无法找到 .message-content 元素!', messageDiv);
        return;
    }
    
    if (role === 'user') {
        // 用户消息使用简单格式化
        messageContent.innerHTML = formatMessage(content);
        // console.log('用户消息已渲染');
    } else {
        // AI消息使用Markdown渲染
        const messageRaw = messageDiv.querySelector('.message-raw');
        if (messageRaw) {
            messageRaw.textContent = content; // 保存原文
        } else {
            console.warn('未找到 .message-raw 元素，AI消息可能显示不完整');
        }
        
        const renderedContent = renderMarkdown(content);
        messageContent.innerHTML = renderedContent;
        // console.log('AI消息已渲染，内容长度:', renderedContent.length);
        
        // V0.3.1 处理思考过程恢复（兼容null/undefined）
        if (thinkingProcess && typeof thinkingProcess === 'string' && thinkingProcess.trim()) {
            console.log('[思考过程] 恢复历史思考过程，长度:', thinkingProcess.length);
            addThinkingProcessToMessage(messageDiv, thinkingProcess);
            // 历史消息的思考过程默认折叠
            completeThinkingProcessInMessage(messageDiv, thinkingProcess);
        }
        
        // 代码高亮和复制按钮
        messageContent.querySelectorAll('pre code').forEach((block) => {
            hljs.highlightElement(block);
            addCopyButtonToCodeBlock(block.parentElement);
        });
        
        // 渲染数学公式
        renderMath(messageContent);
    }
    
    scrollToBottom();
}

// 渲染Markdown内容
function renderMarkdown(content) {
    try {
        // 预处理数学公式：处理方括号包围的公式
        content = preprocessMathFormulas(content);
        
        // 配置marked选项
        marked.setOptions({
            breaks: true,
            gfm: true,
            sanitize: false
        });
        
        return marked.parse(content);
    } catch (error) {
        console.error('Markdown渲染失败:', error);
        return formatMessage(content); // 降级到简单格式化
    }
}

// 预处理数学公式
function preprocessMathFormulas(content) {
    // console.log('开始预处理数学公式，原始内容:', content.substring(0, 100) + '...');
    
    // 1. 处理每个独立的LaTeX块级公式 \[ ... \]
    let processedContent = content;
    let matches = [];
    let regex = /\\\[\s*\n?\s*([\s\S]*?)\s*\n?\s*\\\]/g;
    let match;
    
    // 收集所有匹配
    while ((match = regex.exec(content)) !== null) {
        matches.push({
            fullMatch: match[0],
            formula: match[1].trim(),
            index: match.index
        });
    }
    
    // console.log('找到', matches.length, '个LaTeX块级公式');
    
    // 从后往前替换，避免索引偏移
    for (let i = matches.length - 1; i >= 0; i--) {
        const m = matches[i];
        // console.log('处理公式', i + 1, ':', m.formula);
        const replacement = '\n$$' + m.formula + '$$\n';
        processedContent = processedContent.substring(0, m.index) + replacement + processedContent.substring(m.index + m.fullMatch.length);
    }
    
    // 2. 处理LaTeX行内公式 \( ... \)
    processedContent = processedContent.replace(/\\\(\s*(.*?)\s*\\\)/g, function(match, formula) {
        formula = formula.trim();
                    // console.log('发现LaTeX行内公式:', formula);
        return '$' + formula + '$';
    });
    
    // 3. 处理方括号包围的数学公式 [数学内容]
    processedContent = processedContent.replace(/\[\s*([^[\]]*(?:\\[^[\]]*)*[^[\]]*)\s*\]/g, function(match, formula) {
        formula = formula.trim();
        
        // 检查是否包含数学符号
        const mathIndicators = ['\\frac', '\\partial', '\\hat', '\\text', '\\quad', 
                              '\\alpha', '\\beta', '\\gamma', '\\delta', '\\theta', '\\lambda', 
                              '^{', '_{', '\\sum', '\\int', '\\cdot', '\\times'];
        
        const isMathFormula = mathIndicators.some(indicator => formula.includes(indicator));
        
        if (isMathFormula) {
            // console.log('发现方括号数学公式:', formula);
            return '\n$$' + formula + '$$\n';
        }
        
        return match;
    });
    
    // 4. 清理重复的标记
    processedContent = processedContent.replace(/\$\$\s*\$\$/g, '$$');
    processedContent = processedContent.replace(/\$\s*\$/g, '$');
    
    // console.log('数学公式预处理完成，处理后内容:', processedContent.substring(0, 100) + '...');
    return processedContent;
}

// 渲染数学公式
function renderMath(element) {
    if (window.MathJax && window.MathJax.typesetPromise) {
        // 清除之前的MathJax处理
        window.MathJax.typesetClear([element]);
        
        // 重新渲染数学公式
        window.MathJax.typesetPromise([element]).then(function() {
            // console.log('MathJax渲染完成');
        }).catch(function (err) {
            // console.log('MathJax渲染错误:', err.message);
        });
    }
}

// 简单格式化消息内容（用于用户消息）
function formatMessage(content) {
    return content
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/`(.*?)`/g, '<code>$1</code>')
        .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
        .replace(/\n/g, '<br>');
}

// 切换消息显示格式（渲染/原文）
function toggleMessageFormat(messageId) {
    const contentDiv = document.getElementById(messageId);
    const rawDiv = document.getElementById(messageId + '_raw');
    const toggleBtn = document.querySelector(`[onclick="toggleMessageFormat('${messageId}')"]`);
    
    if (contentDiv.style.display === 'none') {
        // 切换到渲染视图
        contentDiv.style.display = 'block';
        rawDiv.style.display = 'none';
        toggleBtn.innerHTML = '<i class="bi bi-eye"></i> 渲染';
        toggleBtn.title = '切换到原文视图';
    } else {
        // 切换到原文视图
        contentDiv.style.display = 'none';
        rawDiv.style.display = 'block';
        toggleBtn.innerHTML = '<i class="bi bi-code"></i> 原文';
        toggleBtn.title = '切换到渲染视图';
    }
}

// 打字指示器功能已移除

// 滚动到底部
function scrollToBottom() {
    const chatMessages = document.getElementById('chatMessages');
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// 插入快捷文本
function insertQuickText(text) {
    const messageInput = document.getElementById('messageInput');
    messageInput.value = text;
    messageInput.focus();
    messageInput.style.height = 'auto';
    messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
    document.getElementById('sendBtn').disabled = false;
}

// 保存消息到数据库
async function saveMessage(conversationId, messageId, content, role = 'assistant') {
    try {
        const response = await fetch('/api/save_message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                conversation_id: conversationId,
                message_id: messageId,
                content: content,
                role: role
            })
        });
        
        const data = await response.json();
        if (!data.success) {
            console.error('保存消息失败:', data.message);
        }
    } catch (error) {
        console.error('保存消息异常:', error);
    }
}

// V0.3.0 移除知识库选择功能 - 该函数已删除

// V0.3.0 DeepSeek R1 思考过程显示功能
function addThinkingProcessToMessage(messageDiv, thinkingProcess) {
    if (!thinkingProcess || !thinkingProcess.trim()) {
        return;
    }
    
    // 检查是否已经存在思考过程，避免重复添加
    if (messageDiv.querySelector('.thinking-process-container')) {
        return;
    }
    
    // 创建思考过程容器
    const thinkingContainer = document.createElement('div');
    thinkingContainer.className = 'thinking-process-container';
    
    // 创建展开/折叠按钮
    const toggleButton = document.createElement('button');
    toggleButton.className = 'btn btn-link btn-sm thinking-toggle-btn p-1';
    toggleButton.innerHTML = `
        <i class="bi bi-chevron-right me-1"></i>
        <i class="bi bi-brain me-1 text-muted"></i>
        <span class="text-muted small">查看深度思考过程</span>
    `;
    
    // 创建思考内容区域
    const thinkingContent = document.createElement('div');
    thinkingContent.className = 'thinking-content';
    thinkingContent.style.display = 'none';
    thinkingContent.innerHTML = `
        <div class="thinking-text p-2 border-start border-2 border-primary bg-light" style="color: #666; font-size: 0.9em;">
            ${renderMarkdown(thinkingProcess)}
        </div>
    `;
    
    // 添加展开/折叠功能
    toggleButton.addEventListener('click', function() {
        const isExpanded = thinkingContent.style.display !== 'none';
        
        if (isExpanded) {
            // 折叠
            thinkingContent.style.display = 'none';
            toggleButton.innerHTML = `
                <i class="bi bi-chevron-right me-1"></i>
                <i class="bi bi-brain me-1 text-muted"></i>
                <span class="text-muted small">查看深度思考过程</span>
            `;
        } else {
            // 展开
            thinkingContent.style.display = 'block';
            toggleButton.innerHTML = `
                <i class="bi bi-chevron-down me-1"></i>
                <i class="bi bi-brain me-1 text-muted"></i>
                <span class="text-muted small">隐藏思考过程</span>
            `;
            
            // 代码高亮
            thinkingContent.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
                addCopyButtonToCodeBlock(block.parentElement);
            });
            
            // 渲染数学公式
            if (typeof renderMath === 'function') {
                renderMath(thinkingContent);
            }
        }
    });
    
    // 组装容器
    thinkingContainer.appendChild(toggleButton);
    thinkingContainer.appendChild(thinkingContent);
    
    // 在消息内容之前插入思考过程
    const messageContent = messageDiv.querySelector('.message-content');
    if (messageContent) {
        messageContent.parentNode.insertBefore(thinkingContainer, messageContent);
    }
}

// V0.3.1 新增：流式思考过程处理函数
function addThinkingStreamToMessage(messageDiv, content) {
    if (!content) return;
    
    let thinkingContainer = messageDiv.querySelector('.thinking-process-container');
    
    // 如果不存在思考过程容器，创建它
    if (!thinkingContainer) {
        thinkingContainer = document.createElement('div');
        thinkingContainer.className = 'thinking-process-container';
        
        // 创建标题栏，显示思考正在进行
        const thinkingHeader = document.createElement('div');
        thinkingHeader.className = 'thinking-header p-2 bg-primary bg-opacity-10 border-start border-2 border-primary';
        thinkingHeader.innerHTML = `
            <i class="bi bi-brain me-2 text-primary"></i>
            <span class="text-primary small fw-bold">AI正在深度思考中...</span>
            <i class="bi bi-arrow-repeat spin ms-2 text-primary"></i>
        `;
        
        // 创建思考内容区域（展开状态显示流式内容）
        const thinkingContent = document.createElement('div');
        thinkingContent.className = 'thinking-content-stream';
        thinkingContent.style.display = 'block';
        thinkingContent.innerHTML = `
            <div class="thinking-text p-2 border-start border-2 border-primary bg-light" style="color: #666; font-size: 0.9em;">
                <div class="thinking-stream-content"></div>
            </div>
        `;
        
        thinkingContainer.appendChild(thinkingHeader);
        thinkingContainer.appendChild(thinkingContent);
        
        // 在消息内容之前插入思考过程
        const messageContent = messageDiv.querySelector('.message-content');
        if (messageContent) {
            messageContent.parentNode.insertBefore(thinkingContainer, messageContent);
        }
    }
    
    // 添加流式内容到思考过程
    const streamContent = thinkingContainer.querySelector('.thinking-stream-content');
    if (streamContent) {
        streamContent.textContent += content;
    }
}

// V0.3.1 新增：完成思考过程并自动折叠
function completeThinkingProcessInMessage(messageDiv, fullThinkingProcess) {
    const thinkingContainer = messageDiv.querySelector('.thinking-process-container');
    if (!thinkingContainer) return;
    
    // 移除流式显示的内容
    const streamContent = thinkingContainer.querySelector('.thinking-content-stream');
    if (streamContent) {
        streamContent.remove();
    }
    
    // 移除思考头部
    const thinkingHeader = thinkingContainer.querySelector('.thinking-header');
    if (thinkingHeader) {
        thinkingHeader.remove();
    }
    
    // 创建折叠状态的思考过程界面
    const toggleButton = document.createElement('button');
    toggleButton.className = 'btn btn-link btn-sm thinking-toggle-btn p-1';
    toggleButton.innerHTML = `
        <i class="bi bi-chevron-right me-1"></i>
        <i class="bi bi-brain me-1 text-muted"></i>
        <span class="text-muted small">查看深度思考过程</span>
    `;
    
    // 创建折叠的思考内容区域
    const thinkingContent = document.createElement('div');
    thinkingContent.className = 'thinking-content';
    thinkingContent.style.display = 'none'; // 默认折叠
    thinkingContent.innerHTML = `
        <div class="thinking-text p-2 border-start border-2 border-primary bg-light" style="color: #666; font-size: 0.9em;">
            ${renderMarkdown(fullThinkingProcess)}
        </div>
    `;
    
    // 添加展开/折叠功能
    toggleButton.addEventListener('click', function() {
        const isExpanded = thinkingContent.style.display !== 'none';
        
        if (isExpanded) {
            // 折叠
            thinkingContent.style.display = 'none';
            toggleButton.innerHTML = `
                <i class="bi bi-chevron-right me-1"></i>
                <i class="bi bi-brain me-1 text-muted"></i>
                <span class="text-muted small">查看深度思考过程</span>
            `;
        } else {
            // 展开
            thinkingContent.style.display = 'block';
            toggleButton.innerHTML = `
                <i class="bi bi-chevron-down me-1"></i>
                <i class="bi bi-brain me-1 text-muted"></i>
                <span class="text-muted small">隐藏思考过程</span>
            `;
            
            // 代码高亮
            thinkingContent.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
                addCopyButtonToCodeBlock(block.parentElement);
            });
            
            // 渲染数学公式
            if (typeof renderMath === 'function') {
                renderMath(thinkingContent);
            }
        }
    });
    
    // 重新组装容器
    thinkingContainer.innerHTML = '';
    thinkingContainer.appendChild(toggleButton);
    thinkingContainer.appendChild(thinkingContent);
}

// V0.3.0 处理聊天简单API的思考过程响应
function handleSimpleChatThinking(response) {
    if (response.has_thinking && response.thinking_process) {
        // 如果有思考过程，显示给用户
        const lastAssistantMessage = document.querySelector('.message.assistant:last-child');
        if (lastAssistantMessage) {
            addThinkingProcessToMessage(lastAssistantMessage, response.thinking_process);
        }
    }
}

// 发送按钮状态管理函数
function updateSendButtonState() {
    const sendBtn = document.getElementById('sendBtn');
    const messageInput = document.getElementById('messageInput');
    
    if (!sendBtn || !messageInput) return;
    
    const hasContent = messageInput.value.trim().length > 0;
    
    if (isLoading) {
        // 加载状态：禁用按钮，显示加载图标
        sendBtn.disabled = true;
        sendBtn.innerHTML = '<i class="bi bi-arrow-repeat spin"></i>';
    } else {
        // 非加载状态：根据内容决定按钮状态
        sendBtn.disabled = !hasContent;
        sendBtn.innerHTML = '<i class="bi bi-send"></i>';
    }
}

// 强制重置加载状态（仅在真正需要时调用）
function forceResetLoadingState() {
    isLoading = false;
    updateSendButtonState();
    
    // 确保输入框可用
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.disabled = false;
        messageInput.focus();
    }
}

// 显示提示消息（如果不存在的话）
function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} position-fixed`;
    toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);';
    toast.innerHTML = `
        <div class="d-flex align-items-center">
            <i class="bi bi-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-triangle' : 'info-circle'} me-2"></i>
            <span>${message}</span>
        </div>
    `;
    
    document.body.appendChild(toast);
    
    // 5秒后自动消失
    setTimeout(() => {
        if (toast.parentNode) {
            toast.remove();
        }
    }, 5000);
}

// 检查是否启用思考过程显示
function shouldShowThinkingProcess() {
    const checkbox = document.getElementById('enableThinking');
    const modelName = currentConfig.model_name;
    return checkbox && checkbox.checked && modelName === 'deepseek-reasoner';
}

// 分享对话到论坛 - 显示专业模态框
function shareConversation(conversationId, event) {
    // 阻止事件冒泡，避免触发切换对话
    if (event) {
        event.stopPropagation();
        event.preventDefault();
    }
    
    // 获取对话信息
    const conversation = conversations.find(c => c.id === conversationId);
    if (!conversation) {
        showToast('对话不存在', 'error');
        return;
    }
    
    // 检查对话是否有消息
    if (!conversation.message_count || conversation.message_count === 0) {
        showToast('空对话无法分享', 'error');
        return;
    }
    
    // 打开分享模态框
    openShareConversationModal(conversation);
}

// 打开分享对话模态框
function openShareConversationModal(conversation) {
    const modal = document.getElementById('shareConversationModal');
    const titleInput = document.getElementById('shareConversationTitle');
    const descriptionTextarea = document.getElementById('shareConversationDescription');
    const tagsInput = document.getElementById('shareConversationTags');
    const messageCountSpan = document.getElementById('shareConversationMessageCount');
    const modelSpan = document.getElementById('shareConversationModel');
    const timeSpan = document.getElementById('shareConversationTime');
    const form = document.getElementById('shareConversationForm');
    
    // 填充对话信息
    titleInput.value = conversation.title;
    descriptionTextarea.value = `这是一段关于"${conversation.title}"的精彩AI对话，分享给大家！`;
    tagsInput.value = 'AI对话,分享';
    
    // 填充统计信息
    messageCountSpan.textContent = conversation.message_count || 0;
    modelSpan.textContent = conversation.model_display_name || 'DeepSeek';
    
    // 格式化时间
    if (conversation.updated_at) {
        const date = new Date(conversation.updated_at);
        timeSpan.textContent = date.toLocaleString('zh-CN');
    } else {
        timeSpan.textContent = '未知';
    }
    
    // 更新字符计数器
    updateCharCounter();
    
    // 设置表单提交处理
    form.onsubmit = function(e) {
        e.preventDefault();
        handleShareConversationSubmit(conversation.id);
    };
    
    // 显示模态框
    modal.style.display = 'block';
    
    // 聚焦到描述输入框
    setTimeout(() => {
        descriptionTextarea.focus();
        descriptionTextarea.setSelectionRange(0, descriptionTextarea.value.length);
    }, 100);
}

// 关闭分享对话模态框
function closeShareConversationModal() {
    const modal = document.getElementById('shareConversationModal');
    modal.style.display = 'none';
}

// 更新字符计数器
function updateCharCounter() {
    const descriptionTextarea = document.getElementById('shareConversationDescription');
    const charCounter = document.getElementById('shareDescriptionCharCounter');
    
    const currentLength = descriptionTextarea.value.length;
    const maxLength = 140;
    charCounter.textContent = `${currentLength}/${maxLength}`;
    
    // 超出限制时显示红色
    if (currentLength > maxLength) {
        charCounter.style.color = '#dc2626';
        descriptionTextarea.style.borderColor = '#dc2626';
    } else {
        charCounter.style.color = '#64748b';
        descriptionTextarea.style.borderColor = '#e2e8f0';
    }
}

// 处理分享表单提交
async function handleShareConversationSubmit(conversationId) {
    const descriptionTextarea = document.getElementById('shareConversationDescription');
    const tagsInput = document.getElementById('shareConversationTags');
    const submitBtn = document.getElementById('submitShareBtn');
    
    const description = descriptionTextarea.value.trim();
    const tags = tagsInput.value.trim();
    
    // 验证必填字段
    if (!description) {
        showToast('请输入分享描述', 'error');
        descriptionTextarea.focus();
        return;
    }
    
    if (description.length > 140) {
        showToast('分享描述不能超过140字符', 'error');
        descriptionTextarea.focus();
        return;
    }
    
    // 禁用提交按钮
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="bi bi-arrow-repeat spin"></i> 分享中...';
    
    try {
        // 处理标签
        let tagArray = ['AI对话', '分享']; // 默认标签
        if (tags) {
            const customTags = tags.split(/[,，]/).map(tag => tag.trim()).filter(tag => tag.length > 0);
            tagArray = [...new Set([...tagArray, ...customTags])]; // 去重
        }
        
        // 调用分享API
        const response = await fetch('/api/community/posts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: description,
                ai_content_type: 'conversation',
                ai_content_data: {
                    conversation_id: conversationId
                },
                tags: tagArray
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // 关闭模态框
            closeShareConversationModal();
            
            // 显示成功提示
            showToast('分享成功！', 'success');
            
            // 询问是否跳转到论坛查看
            setTimeout(() => {
                if (confirm('分享成功！是否跳转到论坛查看？')) {
                    window.open('/community', '_blank');
                }
            }, 500);
        } else {
            showToast(`分享失败：${result.message}`, 'error');
        }
        
    } catch (error) {
        console.error('分享对话失败:', error);
        showToast('分享失败，请稍后重试', 'error');
    } finally {
        // 恢复提交按钮
        submitBtn.disabled = false;
        submitBtn.innerHTML = '<i class="bi bi-share"></i> 分享到论坛';
    }
}

// 标题编辑功能
function startEditTitle() {
    const titleElement = document.getElementById('currentChatTitle');
    const editorElement = document.getElementById('titleEditor');
    
    // 如果没有对话ID，不允许编辑
    if (!currentConversationId) {
        showToast('开始对话后可以编辑标题', 'info');
        return;
    }
    
    const currentTitle = titleElement.textContent.trim();
    
    // 隐藏标题，显示编辑器
    titleElement.style.display = 'none';
    editorElement.style.display = 'block';
    editorElement.value = currentTitle;
    
    // 聚焦并选中所有文本
    setTimeout(() => {
        editorElement.focus();
        editorElement.select();
    }, 10);
    
    // 设置事件监听器
    editorElement.onkeydown = function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            saveTitle();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            cancelEditTitle();
        }
    };
    
    editorElement.onblur = function() {
        saveTitle();
    };
}

// 取消编辑标题
function cancelEditTitle() {
    const titleElement = document.getElementById('currentChatTitle');
    const editorElement = document.getElementById('titleEditor');
    
    editorElement.style.display = 'none';
    titleElement.style.display = 'block';
    
    // 移除事件监听器
    editorElement.onkeydown = null;
    editorElement.onblur = null;
}

// 保存标题
async function saveTitle() {
    const titleElement = document.getElementById('currentChatTitle');
    const editorElement = document.getElementById('titleEditor');
    const newTitle = editorElement.value.trim();
    
    // 如果标题为空，取消编辑
    if (!newTitle) {
        showToast('标题不能为空', 'error');
        editorElement.focus();
        return;
    }
    
    // 如果标题没有变化，直接取消编辑
    const originalTitle = titleElement.textContent.trim();
    if (newTitle === originalTitle) {
        cancelEditTitle();
        return;
    }
    
    try {
        // 调用API更新标题
        const response = await fetch(`/api/conversations/${currentConversationId}/title`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                title: newTitle
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // 更新页面标题显示
            const titleText = titleElement.childNodes[0];
            if (titleText && titleText.nodeType === Node.TEXT_NODE) {
                titleText.textContent = newTitle;
            } else {
                // 如果结构有变化，重新设置内容
                titleElement.innerHTML = `${newTitle}<i class="bi bi-pencil-square edit-icon"></i>`;
            }
            
            // 更新侧边栏对话列表中的标题
            updateConversationListTitle(currentConversationId, newTitle);
            
            showToast('标题已更新', 'success');
        } else {
            showToast(`更新标题失败：${result.message}`, 'error');
        }
    } catch (error) {
        console.error('更新标题失败:', error);
        showToast('更新标题失败，请稍后重试', 'error');
    }
    
    // 隐藏编辑器，显示标题
    cancelEditTitle();
}

// 更新侧边栏对话列表中的标题
function updateConversationListTitle(conversationId, newTitle) {
    // 更新内存中的对话数据
    const conversation = conversations.find(c => c.id === conversationId);
    if (conversation) {
        conversation.title = newTitle;
    }
    
    // 更新DOM中的标题显示
    const conversationElement = document.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
    if (conversationElement) {
        const titleElement = conversationElement.querySelector('.conversation-title');
        if (titleElement) {
            titleElement.textContent = newTitle;
        }
    }
}

// V0.3.1 修复：删除重复的toggleDebugMode函数定义，使用前面的版本
</script>

<style>
/* 聊天布局样式 */
.chat-layout {
    display: flex;
    flex-direction: column;
    height: calc(100vh - 120px);
    background: #ffffff;
    border-radius: 12px;
    overflow: hidden;
    border: 1px solid rgba(37, 99, 235, 0.1);
}

.chat-header {
    padding: 1rem; /* 🔥 缩小：从1.5rem改为1rem */
    border-bottom: 1px solid rgba(37, 99, 235, 0.1);
    background: #ffffff;
}

.chat-messages-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem; /* 🔥 缩小：从1.5rem改为1rem */
    background: #fafafa;
}

.chat-messages::-webkit-scrollbar {
    width: 6px;
}

.chat-messages::-webkit-scrollbar-track {
    background: transparent;
}

.chat-messages::-webkit-scrollbar-thumb {
    background: rgba(37, 99, 235, 0.2);
    border-radius: 10px;
}

.chat-messages::-webkit-scrollbar-thumb:hover {
    background: rgba(37, 99, 235, 0.3);
}

/* 欢迎消息样式 */
.welcome-message {
    text-align: center;
    padding: 3rem 1rem;
    color: #64748b;
}

.welcome-icon {
    font-size: 3rem;
    color: var(--accent);
    margin-bottom: 1rem;
    display: block;
}

.welcome-message h4 {
    margin-bottom: 0.5rem;
    color: #334155;
}

/* 这些样式已在主CSS文件中定义，无需重复 */

/* message-avatar 样式已在主CSS文件中定义 */

/* message-bubble样式已在主CSS文件中定义 */

/* 用户消息气泡样式已在主CSS文件中定义 */

/* AI消息气泡样式已在主CSS文件中定义 */

.message-bubble.error {
    background: #fef2f2;
    border: 1px solid #fecaca;
    color: #dc2626;
}

.message-content {
    font-size: 14px; /* 🔥 字体缩小：从15px改为14px */
}

.message-content pre {
    background: rgba(0, 0, 0, 0.05);
    padding: 0.6rem; /* 🔥 缩小：从0.75rem改为0.6rem */
    border-radius: 0.4rem; /* 🔥 缩小：从0.5rem改为0.4rem */
    margin: 0.4rem 0; /* 🔥 缩小：从0.5rem改为0.4rem */
    overflow-x: auto;
    font-size: 13px; /* 🔥 字体缩小：从14px改为13px */
}

.message-content code {
    background: rgba(0, 0, 0, 0.1);
    padding: 0.15rem 0.3rem; /* 🔥 缩小：从0.2rem 0.4rem改为0.15rem 0.3rem */
    border-radius: 0.2rem; /* 🔥 缩小：从0.25rem改为0.2rem */
    font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
    font-size: 13px; /* 🔥 字体缩小：从14px改为13px */
}

.message-content strong {
    font-weight: 600;
}

.message-content em {
    font-style: italic;
}

/* 分享对话模态框样式 */
.share-conversation-modal {
    display: none;
    position: fixed;
    z-index: 1050;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(4px);
}

.share-conversation-content {
    position: relative;
    background: #ffffff;
    margin: 5% auto;
    max-width: 500px;
    border-radius: 12px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
    overflow: hidden;
    animation: modalSlideIn 0.3s ease-out;
}

@keyframes modalSlideIn {
    from {
        transform: translateY(-50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.share-conversation-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px 28px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.share-conversation-header h3 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
}

.close-modal {
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    font-weight: 300;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background-color 0.2s ease;
}

.close-modal:hover {
    background: rgba(255, 255, 255, 0.1);
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    margin-bottom: 6px;
    font-weight: 600;
    color: #334155;
    font-size: 14px;
}

.form-group .form-control {
    width: 100%;
    padding: 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 14px;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.form-group .form-control:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.char-counter {
    text-align: right;
    font-size: 12px;
    color: #64748b;
    margin-top: 4px;
}

.conversation-stats {
    display: flex;
    gap: 16px;
    background: #f8fafc;
    padding: 12px;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
}

.stat-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 13px;
    color: #475569;
}

.stat-item i {
    color: #667eea;
}

.share-conversation-actions {
    display: flex;
    justify-content: flex-end;
    gap: 12px;
    margin-top: 24px;
    padding-top: 20px;
    border-top: 1px solid #e2e8f0;
}

.share-conversation-actions .btn {
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 500;
    font-size: 14px;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
}

.share-conversation-actions .btn-secondary {
    background: #f1f5f9;
    color: #475569;
}

.share-conversation-actions .btn-secondary:hover {
    background: #e2e8f0;
}

.share-conversation-actions .btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.share-conversation-actions .btn-primary:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.share-conversation-actions .btn-primary:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* 响应式设计 */
@media (max-width: 576px) {
    .share-conversation-content {
        margin: 2% auto;
        max-width: 95%;
        border-radius: 8px;
    }
    
    .share-conversation-header {
        padding: 16px 20px;
    }
    
    .share-conversation-header h3 {
        font-size: 16px;
    }
    
    .conversation-stats {
        flex-direction: column;
        gap: 8px;
    }
    
    .share-conversation-actions {
        flex-direction: column-reverse;
    }
    
    .share-conversation-actions .btn {
        width: 100%;
        margin: 0;
    }
}

/* 动画优化 */
.share-conversation-content {
    transform-origin: center top;
}

/* 加载状态动画 */
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.bi-arrow-repeat.spin {
    animation: spin 1s linear infinite;
}

/* 可编辑标题样式 */
.editable-title {
    cursor: pointer;
    position: relative;
    transition: color 0.2s ease;
    border-radius: 4px;
    padding: 4px 8px;
    margin: -4px -8px;
}

.editable-title:hover {
    background: rgba(102, 126, 234, 0.1);
    color: #667eea;
}

.edit-icon {
    opacity: 0;
    font-size: 12px;
    margin-left: 8px;
    transition: opacity 0.2s ease;
}

.editable-title:hover .edit-icon {
    opacity: 0.6;
}

.title-editor {
    font-size: 1.25rem;
    font-weight: 500;
    border: 2px solid #667eea;
    border-radius: 6px;
    transition: all 0.2s ease;
}

.title-editor:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

/* 优化标题行布局 */
.chat-header .d-flex.justify-content-between {
    align-items: center;
    min-height: 48px;
}

.chat-header .d-flex.align-items-center > div {
    flex: 1;
    min-width: 0; /* 允许文本收缩 */
}

.editable-title {
    word-break: break-word;
    max-width: calc(100vw - 300px); /* 为按钮预留空间 */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* 编辑状态下的标题输入框 */
.title-editor {
    max-width: calc(100vw - 300px); /* 与标题保持一致 */
}

/* 响应式按钮组 */
@media (max-width: 768px) {
    .chat-header .d-flex.gap-2 {
        gap: 0.5rem !important;
    }
    
    .chat-header .btn-sm {
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
    }
    
    .chat-header .btn-sm .bi {
        display: none; /* 小屏幕时隐藏图标 */
    }
}

/* 输入区域样式 */
.chat-input-container {
    background: #ffffff;
    border-top: 1px solid rgba(37, 99, 235, 0.1);
    padding: 1rem; /* 🔥 缩小：从1.5rem改为1rem */
}

.chat-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}

.knowledge-base-selector {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.knowledge-base-selector select {
    width: auto;
    min-width: 150px;
}

.quick-actions {
    display: flex;
    gap: 0.5rem;
}

.chat-input-form {
    margin: 0;
}

/* input-wrapper样式已在主CSS文件中定义 */

/* input-wrapper:focus-within样式已在主CSS文件中定义 */

/* chat-input样式已在主CSS文件中定义 */

.chat-input::placeholder {
    color: #94a3b8;
}

/* send-btn样式已在主CSS文件中定义 */

/* send-btn hover和disabled样式已在主CSS文件中定义 */

/* 打字指示器样式 */
.typing-indicator {
    display: none;
    padding: 0 1.5rem 1rem;
}

.typing-dots {
    display: inline-flex;
    margin-left: 0.5rem;
}

.typing-dots span {
    height: 4px;
    width: 4px;
    border-radius: 50%;
    background-color: var(--accent);
    margin: 0 1px;
    animation: typing 1.4s infinite ease-in-out;
}

.typing-dots span:nth-child(1) { animation-delay: -0.32s; }
.typing-dots span:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
    0%, 80%, 100% { 
        transform: scale(0.8); 
        opacity: 0.5; 
    }
    40% { 
        transform: scale(1); 
        opacity: 1; 
    }
}

/* 响应式设计 */
@media (max-width: 768px) {
    .chat-layout {
        height: calc(100vh - 80px);
    }
    
    .chat-controls {
        flex-direction: column;
        gap: 1rem;
        align-items: stretch;
    }
    
    .quick-actions {
        justify-content: center;
        flex-wrap: wrap;
    }
    
    .message-bubble {
        max-width: 85%;
    }
}

/* V0.3.0 DeepSeek R1 思考过程样式 */
.thinking-process-container {
    margin-bottom: 1rem;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    background: #f9fafb;
    overflow: hidden;
}

.thinking-toggle-btn {
    width: 100%;
    padding: 0.75rem 1rem;
    text-align: left;
    border: none;
    background: transparent;
    color: #6b7280;
    font-size: 0.875rem;
    text-decoration: none;
    display: flex;
    align-items: center;
    transition: all 0.2s ease;
}

.thinking-toggle-btn:hover {
    background: #f3f4f6;
    color: #374151;
    text-decoration: none;
}

.thinking-toggle-btn:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
}

.thinking-content {
    border-top: 1px solid #e5e7eb;
    background: #ffffff;
}

.thinking-text {
    padding: 1rem;
    color: #6b7280;
    font-size: 0.9rem;
    line-height: 1.6;
}

.thinking-text h1, .thinking-text h2, .thinking-text h3, 
.thinking-text h4, .thinking-text h5, .thinking-text h6 {
    color: #6b7280;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    opacity: 0.8;
}

.thinking-text p {
    margin-bottom: 0.75rem;
    color: #6b7280;
}

.thinking-text ul, .thinking-text ol {
    color: #6b7280;
    padding-left: 1.5rem;
}

.thinking-text pre {
    background: #f3f4f6;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    padding: 0.75rem;
    margin: 0.75rem 0;
    overflow-x: auto;
}

.thinking-text code {
    background: #f3f4f6;
    color: #6b7280;
    padding: 0.125rem 0.25rem;
    border-radius: 3px;
    font-size: 0.85rem;
}

.thinking-text blockquote {
    border-left: 3px solid #d1d5db;
    padding-left: 1rem;
    margin: 0.75rem 0;
    color: #6b7280;
    font-style: italic;
}

/* 思考过程动画效果 */
.thinking-content {
    animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
    from {
        opacity: 0;
        max-height: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        max-height: 1000px;
        transform: translateY(0);
    }
}

/* 对话操作按钮样式 */
.conversation-actions {
    display: flex;
    align-items: center;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.conversation-item:hover .conversation-actions {
    opacity: 1;
}

.conversation-actions .btn {
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    border-radius: 4px;
    min-width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.conversation-actions .btn-outline-primary {
    border-color: #3b82f6;
    color: #3b82f6;
    transition: all 0.2s ease;
}

.conversation-actions .btn-outline-primary:hover {
    background-color: #3b82f6;
    color: white;
    transform: translateY(-1px);
}

.conversation-actions .btn-outline-danger {
    border-color: #ef4444;
    color: #ef4444;
    transition: all 0.2s ease;
}

.conversation-actions .btn-outline-danger:hover {
    background-color: #ef4444;
    color: white;
    transform: translateY(-1px);
}
</style>

<script>
// 为代码块添加复制按钮
function addCopyButtonToCodeBlock(preElement) {
    // 如果已经有复制按钮，不重复添加
    if (preElement.querySelector('.code-copy-btn')) {
        return;
    }
    
    const copyBtn = document.createElement('button');
    copyBtn.className = 'code-copy-btn';
    copyBtn.innerHTML = '复制';
    copyBtn.title = '复制代码';
    
    copyBtn.addEventListener('click', async function() {
        const codeElement = preElement.querySelector('code');
        if (!codeElement) return;
        
        const text = codeElement.textContent;
        
        try {
            await navigator.clipboard.writeText(text);
            
            // 显示复制成功状态
            const originalText = copyBtn.innerHTML;
            copyBtn.innerHTML = '已复制';
            copyBtn.classList.add('copied');
            
            // 2秒后恢复原状
            setTimeout(() => {
                copyBtn.innerHTML = originalText;
                copyBtn.classList.remove('copied');
            }, 2000);
            
        } catch (err) {
            console.error('复制失败:', err);
            
            // 降级到旧版本复制方法
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            // 显示复制成功状态
            const originalText = copyBtn.innerHTML;
            copyBtn.innerHTML = '已复制';
            copyBtn.classList.add('copied');
            
            setTimeout(() => {
                copyBtn.innerHTML = originalText;
                copyBtn.classList.remove('copied');
            }, 2000);
        }
    });
    
    preElement.appendChild(copyBtn);
}
</script>

{% endblock %} 